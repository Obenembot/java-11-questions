1.

public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. intstream.rangeclosed(l, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS D.

2.

interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


7. 

        Integer[] ints = {1,2,3,4,5,6,7};
        var list = Arrays.asList (ints);
        UnaryOperator<Integer> uo =  x -> x *  3; // line 11
        list.replaceAll (uo);

Which can replace line 11?
A . UnaryOperator<Interger > uo = (var x ) -> (x * 3);
B . UnaryOperator<Interger >uo = var x -> { return x 3 ; };
C . UnaryOperator<Interger >uo = x -> { return x * 3; };
D . UnaryOperator<Interger >uo = (int x) -> x * 3;

CORRECT ANSWER IS A AND C.

8.

GIVEN:

@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }
    String name() default "";
    Type type();
}

What is the correct definion of the JsonField annotaon that makes the Point class compile?

A. 
@Target(ElementType.FIELD)
public class Point {
    @JsonField(type = JsonField.Type.STRING)
    private String _name;

    @JsonField(type = JsonField.Type.INT)
    private int x;

    @JsonField(type = JsonField.Type.INT)
    private int y;
}

B.
@Target(ElementType.FIELD)
@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() ;

    Type type();
}

C.
@Target(ElementType.FIELD)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

D.
@Retention(RetentionPolicy.CLASS)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

CORRECT ANSWER IS A.

9.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes.isDirectory());
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . BasicFileAttributes attributes = Files.isDirectory(path);
B . BasicFileAttributes attributes =Files.getAribute (path, ''insdirectory'');
C . BasicFileAttributes attributes = Files.readAributes(path, BasicFileAributes.class);
D . BasicFileAttributes attributes = Files.readAributes(path, FileAributes.class);

CORRECT ANSWER IS C.

10.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . boolean attributes = Files.isDirectory(path);
B . boolean attributes =Files.getAribute (path, ''insdirectory'').isDirectory();
C . boolean attributes = Files.readAributes(path, BasicFileAributes.class).isDirectory();
D . boolean attributes = Files.readAributes(path, FileAributes.class).isDirectory();

CORRECT ANSWER IS A AND C.

11.
Given the code fragment:
public class Main {
    class L extends Exception {
    }

    class M extends L {
    }

    class N extends RuntimeException {
    }

    public void p() throws L {
        throw new M();
    }

    public void q() throws N {
        throw new N();
    }

    public static void main(String[] args) {

        try {
            Main main = new Main();
            main.p();
            main.q();
        } // Line 1
    }
}
What change on line 1 will make this code compile?

A . Add catch (L |N e).
B . Add catch (L |M N e).
C . Add catch (L e).
D . Add catch (N | L | M e).
E . Add catch (M |L e).

CORRECT ANSWER IS A AND C.

12.
Given the code fragment:

    public static void main(String[] args) {
        char arrays[] [] = {{'g', 'j'},{'h', 'k'}, {'i', 'l'}};
        for (char[] xx : arrays) {
            for (char yy : xx) {
                System.out.print(yy);
            }
            System.out.print(" ");
        }
    }

What is the result?

A . An ArrayIndexOutofBoundsExcepon is thrown at runme.
B . The compilaon fails.
C . gh ij kl
D . gj hk il
E . ghi jkl

CORRECT ANSWER IS D.

13.
Given:

public  interface AdaptorFirst {
    void showFirst();
}

Which three classes successfully override showFirst ()?

A. 
public abstract class Adaptor implements AdaptorFirst {
    public  String showFirst() {
        return "First";
    }
}

B.
public abstract class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

C.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() ;
}

D.
public  class Adaptor implements AdaptorFirst {
    private void showFirst() {
        System.out.println("First");
    }
}

E.
public abstract class Adaptor implements AdaptorFirst {
    public abstract void showFirst() ;
}

F.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

CORRECT ANSWER IS B AND E AND F.

14.
GIVEN:

public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner");
        private String type;

        private Machine(String type) {
            this.type = type; // line 1
        }

        private void setType(String type) {
            this.type = type; // line 2
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 3
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilaon fails due to an error on line 2.
D. The compilaon fails due to an error on line 1.
E. The compilaon fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS A.

15.
GIVEN: 

public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner"); // line 1
        private String type;

        private void setType(String type) {
            this.type = type; // line 1
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 1
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}
What is the outcome? 

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilaon fails due to an error on line 2.
D. The compilaon fails due to an error on line 1.
E. The compilaon fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS D.

16.
GIVEN: 

public class Main {

    public static void main(String[] args) {
        StringBuilder text1 = new StringBuilder("PPQRRRSTT");
        int i = 0;
        a:
        while (i < text1.length()) {
            char x = text1.charAt(i);
            int j = 0;
            i++;
            b:
            while (j < text1.length()) {
                char y = text1.charAt(j);
                if (i != j && y == x) {
                    text1.deleteCharAt(j);
//line 1
                }
                j++;
            }
        }
        System.out.println(text1);
    }
}

Which two statements inserted independently at line 1 enable this code to print PRRT?
A . i---;
B . connue b;
C . break b;
D . j--;
E . connue a;
F . break a ;

CORRECT ANSWER IS C AND E.

17.
GIVEN: 
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}

What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilaon fails.
D . Keys: 0 Values: 0 Map: 2
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS F.

18.
GIVEN: 
public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}
What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS D.

19.
GIVEN: 
public class Main {
    static Map<String, String> map = new TreeMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real", "NOW"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
        System.out.println(map);
    }
}

What is the result?
A . {P=To, Q=Be, R=Real, S=NOW}
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . {S=Getting,P=To, Q=Be, R=Real}

CORRECT ANSWER IS A.

20.

