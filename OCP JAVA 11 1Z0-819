1.

public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. intstream.rangeclosed(l, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS D.

2.

interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


