1.
public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. IntStream.rangeClosed(1, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS C. WATCH OUT FOR map and convert(int x) method as it expects an int. 
// ranged start inclusive and end exclusive and rangeClosed start and end is inclusive

2.
interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


7. 
        Integer[] ints = {1,2,3,4,5,6,7};
        var list = Arrays.asList (ints);
        UnaryOperator<Integer> uo =  x -> x *  3; // line 11
        list.replaceAll (uo);

Which can replace line 11?
A . UnaryOperator<Interger > uo = (var x ) -> (x * 3);
B . UnaryOperator<Interger >uo = var x -> { return x 3 ; };
C . UnaryOperator<Interger >uo = x -> { return x * 3; };
D . UnaryOperator<Interger >uo = (int x) -> x * 3;

CORRECT ANSWER IS A AND C.

8.

GIVEN:

@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }
    String name() default "";
    Type type();
}

What is the correct definion of the JsonField annotaon that makes the Point class compile?

A. 
@Target(ElementType.FIELD)
public class Point {
    @JsonField(type = JsonField.Type.STRING)
    private String _name;

    @JsonField(type = JsonField.Type.INT)
    private int x;

    @JsonField(type = JsonField.Type.INT)
    private int y;
}

B.
@Target(ElementType.FIELD)
@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() ;

    Type type();
}

C.
@Target(ElementType.FIELD)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

D.
@Retention(RetentionPolicy.CLASS)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

CORRECT ANSWER IS A.

9.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes.isDirectory());
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . BasicFileAttributes attributes = Files.isDirectory(path);
B . BasicFileAttributes attributes =Files.getAribute (path, ''insdirectory'');
C . BasicFileAttributes attributes = Files.readAributes(path, BasicFileAributes.class);
D . BasicFileAttributes attributes = Files.readAributes(path, FileAributes.class);

CORRECT ANSWER IS C.

10.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . boolean attributes = Files.isDirectory(path);
B . boolean attributes =Files.getAribute (path, ''insdirectory'').isDirectory();
C . boolean attributes = Files.readAributes(path, BasicFileAributes.class).isDirectory();
D . boolean attributes = Files.readAributes(path, FileAributes.class).isDirectory();

CORRECT ANSWER IS A AND C.

11.
Given the code fragment:
public class Main {
    class L extends Exception {
    }

    class M extends L {
    }

    class N extends RuntimeException {
    }

    public void p() throws L {
        throw new M();
    }

    public void q() throws N {
        throw new N();
    }

    public static void main(String[] args) {

        try {
            Main main = new Main();
            main.p();
            main.q();
        } // Line 1
    }
}
What change on line 1 will make this code compile?

A . Add catch (L |N e).
B . Add catch (L |M N e).
C . Add catch (L e).
D . Add catch (N | L | M e).
E . Add catch (M |L e).

CORRECT ANSWER IS A AND C.

12.
Given the code fragment:

    public static void main(String[] args) {
        char arrays[] [] = {{'g', 'j'},{'h', 'k'}, {'i', 'l'}};
        for (char[] xx : arrays) {
            for (char yy : xx) {
                System.out.print(yy);
            }
            System.out.print(" ");
        }
    }

What is the result?

A . An ArrayIndexOutofBoundsExcepon is thrown at runme.
B . The compilaon fails.
C . gh ij kl
D . gj hk il
E . ghi jkl

CORRECT ANSWER IS D.

13.
Given:
public  interface AdaptorFirst {
    void showFirst();
}

Which three classes successfully override showFirst ()?

A. 
public abstract class Adaptor implements AdaptorFirst {
    public  String showFirst() {
        return "First";
    }
}

B.
public abstract class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

C.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() ;
}

D.
public  class Adaptor implements AdaptorFirst {
    private void showFirst() {
        System.out.println("First");
    }
}

E.
public abstract class Adaptor implements AdaptorFirst {
    public abstract void showFirst() ;
}

F.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

CORRECT ANSWER IS B AND E AND F.

14.
GIVEN:
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner");
        private String type;

        private Machine(String type) {
            this.type = type; // line 1
        }

        private void setType(String type) {
            this.type = type; // line 2
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 3
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilation fails due to an error on line 2.
D. The compilation fails due to an error on line 1.
E. The compilation fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS B.

15.
GIVEN: 
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner"); // line 1
        private String type;

        private void setType(String type) {
            this.type = type; // line 1
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 1
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}
What is the outcome? 

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilation fails due to an error on line 2.
D. The compilation fails due to an error on line 1.
E. The compilation fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS D.

16.
GIVEN: 
public class Main {

    public static void main(String[] args) {
        StringBuilder text1 = new StringBuilder("PPQRRRSTT");
        int i = 0;
        a:
        while (i < text1.length()) {
            char x = text1.charAt(i);
            int j = 0;
            i++;
            b:
            while (j < text1.length()) {
                char y = text1.charAt(j);
                if (i != j && y == x) {
                    text1.deleteCharAt(j);
//line 1
                }
                j++;
            }
        }
        System.out.println(text1);
    }
}

Which two statements inserted independently at line 1 enable this code to print PRRT?
A . i--;
B . connue b;
C . break b;
D . j--;
E . connue a;
F . break a ;

CORRECT ANSWER IS C AND E.

17.
GIVEN: 
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}

What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilaon fails.
D . Keys: 0 Values: 0 Map: 2
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS F.

18.
GIVEN: 
public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}
What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS D.

19.
GIVEN: 
public class Main {
    static Map<String, String> map = new TreeMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real", "NOW"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
        System.out.println(map);
    }
}

What is the result?
A . {P=To, Q=Be, R=Real, S=NOW}
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . {S=Getting,P=To, Q=Be, R=Real}

CORRECT ANSWER IS A.

20.
GIVEN:
public class Main {
    public static void main(String[] args) {
        Consumer<String> c1 = arg -> System.out.println(arg);
        c1.accept("c1 Accepted");
        Consumer<String> c2 = arg -> System.out.println(arg);
        c2.accept("c2 Accepted");
        c2.andThen(c1).accept("c2 after");
        c2.accept("c2 Accepted Again");
    }
}

What is the result?
A. 
c1 Accepted
c2 Accepted
c2 after
c2 after
c2 Accepted Again

B.
c1 Accepted
c2 after
c2 Accepted Again

C.
c1 Accepted
c2 Accepted
c2 Accepted Again

D.
c2 Accepted
c2 after
c2 after
c2 Accepted Again

E.
c1 Accepted
c2 after
c2 after
c2 Accepted Again

CORRECT ANSWER IS A.

21:
GIVEN:

public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        Arrays.sort(towns, ms);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3

THE CORRECT ANSWER IS C. // NOT IF WHAT WE LOOKING FOR IS FOUND THEN IT RETURNS THE INDEX OF THAT ELEMENT.

22.
GIVEN:
public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3
THE CORRECT ANSWER IS D. // NOT BECAUSE WE DID NOT SORT, RETURNS THE INDEX BUT WITH A NEGATIVE.

23.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        p = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS C.

24.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        plant = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS A.

25.
GIVEN:
class Item {
    public String name;
    public int count;

    public Item(String name, int count) {
        this.name = name;
        this.count = count;
    }
}

public class Main {
    public static void main(String[] args) {
        var items = List.of(new Item("A", 15),
                new Item("B", 3),
                new Item("C", 12),
                new Item("D", 6));

// line 1
        System.out.println("Item for where count less than zero");
    }
}
}

You want to examine the items list it contains an item for which the variable count is below zero.
Which code fragment in line 1 accomplishes this?
A . if (items.stream() .filter(i -> i.count < 0).findFirst ()) {
B . if (items.stream () .filter (i -> i.count < 0) . findAny () ) {
C . if (items.stream () .allmatch (i -> count < 0) < 0) ) {
D . if (items.stream () .anymatch (i -> count < 0) < 0) ) {
E . if (items.stream().anyMatch(i -> i.count < 0 )) {

THE CORRECT ANSWER IS E.

26.
GIVEN:
public class ConSuper {
    protected ConSuper() {
        this(2);
        System.out.println("3");
    }

    protected ConSuper(int a) {
        System.out.println(a);
    }
}

public class ConSub extends ConSuper {
    ConSub() {
        this(4);
        System.out.println("1");
    }
    ConSub(int a) {
        System.out.println(a);
    }
    public static void main(String[] args) {
        new ConSub(4);
    }
}

What is the result?
A . 2134
B . 234
C . 2341
D . 214
THE CORRECT ANSWER IS B.

27.
GIVEN:
public class Main {
    public static void main(String[] args) {
        int i = 0;
        for (; i < 10; i++) {
            System.out.print(++i + " ");
        }
    }
}
What is the result?
A . 1 3 5 7 9
B . 1 3 5 7 9 11
C . 2 4 6 B 10
D . 2 4 6 8

THE CORRECT ANSWER IS A.


28.
public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(2,3,4);
        int sum = numbers.stream().reduce(0, (n, m) -> n + m);
        System.out.println(sum);
    }
}

What is the result?

You want to make the reduction operaon parallelized.
Which two modifications will accomplish this?
A . Replace line 1 with int sum = numbers. Stream (). Interate (0, a -> a+1. Reduce (0, (n m) -> n+m);
B . Replace line 1 with int sum = numbers. ParallelStream ( ). Reduce (0, (n, m ) -> n + m);
C . Replace line 1  with int sum = numbers. Parallel ( ). Stream ( ). Reduce (0, (n, m ) -> n + m);
D . Replace line 1 with int sum = numbers.stream().parallel().reduce(0, (n, m) -> n + m);
E . Replace line 1 with    int sum = numbers.parallelStream().reduce(0, (n, m) -> n + m);;

THE CORRECT ANSWER IS D AND E.

29.
 Which method throws an exception for not-a-number and infinite input values?
A). static float validation1 (String s) throws IllegalArgumentException {
return Float.parseFloat(s);
}
B). static float validation2 (String s, float min, float max) throws IllegalArgumentException {
Float f = Float. parseFloat(s);
}
C).  static float validation2 (String s, float min, float max) throws IllegalArgumentException {
float f = Float. parseFloat(s);
if(!Float.isFinite(f) || f > max){
throw new IllegalArgumentException();
}
Return f;
}
D).static float validation2 (String s, float min, float max) throws IllegalArgumentException{
Float f = Float. parseFloat(s);
if(Float.isFinite(f)  && f < min &&  f > max){
throw new IllegalArgumentException();
}
return f;
}

A . Option A
B. Option B
C. Option C
D. Option D
THE CORRECT ANSWER IS A.

30).
Given: 
public class Main{
private String[] strings =  {“ABCDEFGHIJKLMNOPQRSTUVWXYZ”,
“abcdefghijklmnopqrstuvwxyz”, “0123456789”};
public void write(String filename){
// line 1
for (String str: strings){
ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());
fileChannel.write(buffer);
}
}catch(IOException e){
e.printStackTrace();
}
}
public static void main(String[] args){
Main test = new Main();
Test.write(“file_to_path”);
}
}

You want to obtain the Filechannel object on line 1.
 Which code fragment will accomplish this?
A). try (FileChannel fineChannel = Channels.newChannel (new FileOutputStream(filename)); ){
}
B). try (FileChannel fineChannel =  new FileOutputStream(filename).getChannel()){
}
C). try(FileChannel fileChannel = new FileOutputStream(new FileChannel(filename)); ){
}
D). try(FileChannel fileChannel = new FileChannel (new FileoutputStream(filename)); ){
}

THE CORRECT ANSWER IS B.

31).  Given the code fragment:
8.          public class Test{
9.          private final int x = 1;
10.         static final int y;
11.          public Test() {
12.            System.out.print(x);
13.             System.out.print(y);
14.          } 
15.       public static void main(String[] args){
16.        new Test();
17.    }
18.}

What is the result?
A . 1
B . The compilation fails at line 
C. 10
D. The compilation fails at line 10.
E. The compilation fails at line 13.

THE CORRECT ANSWER IS D.

32.
GIVEN: 
final class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS A. // CAN NOT INHERIT FROM FINAL CLASS

33.
GIVEN: 
class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS D.

34.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            list1.sort((String item1, String item2) -> item1.compareTo(item2));
            list2.sort((String item1, String item2) -> item1.compareTo(item2));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS A.

35.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS A.

36.
Given the content:
MessagesBundle.properties file:
Username = Username
Password = Password
And 
MessagesBundle_fr_FR.properties file:
Username = utilisateur
password = Le passe
And 
MessagesBundle_ru.properties file
Username = Mark
Password = Tyson
And the code fragment:
public class Test{
public static void main(String[] args){
Locale.setDefault(Locale.FRANCE);
ResourceBundle msg = ResourceBundle.getBundle(“MessageBundle”, new Locale(“ru”));
System.out.println(“User ”+ msg.getString(“username”));
System.out.println(“Pass ”+ msg.getString(“password”));
    }
}
What is the result?
A). User = Mark
      Pass = Tyson
B). The compilation fails.
C). A missingResourceException is thrown at runtime.
D). User = Utilisateur
       Pass = Le Passe
E). User Username

THE CORRECT ANSWER IS C.

37.
Given Triple This =.java:
6. import java.util.function.*;
7. public TripleThis{
public static void main(String[] args){
  Function tripler = x -> { return (Integer) x * 3; };
TripleThis.printValue(tripler, 4);
}
public static <T> void printValue(Function f, T num){
System.out.println(f.apply(num));
}  }
Compiling TripleThis.java gives this compiler warning:
Note: TripleTHis.java uses unchecked or unsafe operations.
Which two replacements done together remove this compiler warning?
A . Replace line 9 with function<Integer> triple = x->-{return (Integer)x*3;}.
B. Replace line 12 with public static void printValue function<Integer> f, int num){.
C. Replace line 12 with public static int printValue function<Integer, Integer>, f, T num{.
D. Replace line 12 with public static <T> void privateValue(Function<T, T>f, T num){,
E. Replace line 9 with function<Integer>, Integer> = X -> {return (integer)x * 3; }.

THE CORRECT ANSWER IS D AND E.

38.
Given
public class Employee{
private String name;
private String neighborhood;
private LocalDate birthday;
private int salary;
} 
And 
List<Employee> roster = new ArrayList<>(…);
Map<String, Optional<Employee>> m = roster.stream()
  // Line 1
Which code fragment on line 1 makes the m map contain the employee with the highest salary for each neighborhood?
A).
.collect(Collectors.maxBy(Employee::getSalary, Collectors.groupingBy(Comparator.comparing(e -> e.getNeighborhood()))));
B).
.collect(Collectors.groupingBy(Employee::getNeighborhood, Collectors.maxBy(Comparator.comparing(Employee::getSalary))));
C). 
.collect(Collectors.groupingBy(e -> e.getNeighborhood(), Collectors.maxBy((x, y) -> y.getSalary() – x.getSalary() )));
D).
Collect(Collectors.maxBy(x, y) -> y.getSalary() – x.getSalary(),  Collectors.groupingBy(Employee::getNeighborhood)));

THE CORRECT ANSWER IS B. WATCH OUT FOR C AS WELL IF THE Y AND X AND INTERCHANGED.

39.
Given:
public class Main{ 
public static void main(String[] args){
List l = new ArrayList();
l.add(“hello”);
l.add(“world”);
print(1);
}
private static void print(List<String>… args){
for(List<String> str : args){
System.out.println(str);
       }
    } 
}

Which annotation should be used to removed warnings from complication?
	A.	@SuppressWarnings on the main and print methods
	B•	 @SuppressWarnings(''unchecked'') on main and @SafeVarargs on the print method
	C•	 @SuppressWarnings(''rawtypes'') on main and @SafeVarargs on the print method
	d•	 @SuppressWarnings(''all'') on the main and print methods

THE CORRECT ANSWER IS B.


40.
Given:
jdeps -jdkinternals C:\workspace4\SimpleSecurity\jar\classes.jar
Which describes the expected output?
A . jdeps lists the module dependencies and the package names of all referenced JDK internal APIs. If
any are found, the suggested replacements are output in the console.
B . jdeps outputs an error message that the -jdkinternals opon requires either the -summary or the -
verbose opons to output to the console.
C . The -jdkinternals opon analyzes all classes in the .jar and prints all class-level dependencies.
D . The -jdkinternals opon analyzes all classes in the .jar for class-level dependencies on JDK internal
APIs. If any are found, the results with suggested replacements are output in the console.

THE CORRECT ANSWER IS D.

Explanation:
-jdkinternals option analyzes all classes in the .jar for class-level dependencies on JDK internal APIs. If
any are found, the results with suggested replacements are output in the console

41.
Given:
List<String> longlist = List.of("HELLO", "WORLD","BEAT");
List shortList = new ArrayList<>();

Which code fragment correctly forms a short list of words containing the letter “E”?

A.	longlist.stream().
         filter(w ->  w.indexOf("E")  != -1)
                 .parallel()
                 .forEach(w -> shortList.add(w));
B.	longList.parallelStream()
        .filter(w ->  w.indexOf("E) != -1)
        .forEach(w -> shortList.add(w));

C.	shortList = longlist.stream()
    .filter(w ->  w.indexOf("E) != -1)
            .parallel()
        .collect(Collectors.toList());
D.	longlist.stream()
       .filter(w -> w.indexOf("E)  != -1)
        .parallel()
        .collect(shortList);


THE CORRECT ANSWER IS C AND B AND A.

42.
Given the code fragment:
Path source = Paths.get(''/repo/a/a.txt'');
Path desnaon = Paths.get(''/repo'');
Files.move(source, desnaon); // line 1
Files.delete (source); // line 2
Assuming the source file and desnaon folder exist, what Is the result?
A . A java.nio.file.FileAlreadyExistsExcepon is thrown on line 1.
B . A java.nio.file.NoSuchFileExcepon is thrown on line 2.
C . A copy of /repo/a/a.txt is moved to the /repo directory and /repo/a/a.txt is deleted.
D . a.txt is renamed repo.

THE CORRECT ANSWER IS A.

43.
enum Letter {
    ALPHA(100), BETA(200), GAMMA(300);
    int v;

    Letter(int v) {
    }
  // Line 1
}

Examine this code:
System.out.println(Leer.values()[1]);
What code should be wrien at line 5 for this code to print 200?
A . public String toString() { return String.valueOf(ALPHA.v); }
B . public String toString() { return String.valueOf(Leer.values()[1]); }
C . public String toString() { return String.valueOf(v); }
D . String toString() { return ''200''; }


THE CORRECT ANSWER IS B.

44.
Which two statements independently compile? (Choose two.)

A. List<? super Short> list1 = new ArrayList<Number>();
B. List<? extends Number> list3 = new ArrayList<Byte>();
C. List<? super Number> list2 = new ArrayList<Integer>();
D. List<? extends Number> list4 = new ArrayList<Object>();
E. List<? super Float> list5 = new ArrayList<Double>();

THE CORRECT ANSWER IS A AND B.

45.
Given:
LocalDate d1 = LocalDate.of(1997,2,7);
DateTimeFormaer d =
DateTimeFormaer.ofPaern( /*insert code here*/ );
System.out.println(d.format (d1));
Which paern formats the date as Friday 7th of February 1997?
A . ''eeee dd+''th of''+ MMM yyyy''
B . ''eeee dd'th of' MMM yyyy''
C . ''eeee d+''th of''+ MMMM yyyy''
D . ''eeee d'th of' MMMM yyyy''

THE CORRECT ANSWER IS D.


46.
enum QUALITY {
    A(1000), B(75), C(50);
    int percent;

    private QUALITY(int present) {
        this.percent = percent;
    }
    void checkQuality(QUALITY q) {
        switch(q) {
            case  //* Insert code here */:
                
                System.out.println("Best");
                Default:
                System.out.println("Not best");
            break;
        }
    }
}

Which code fragment can be inserted into the switch statement to print Best?
A . QUALITY.A.ValueOf()
B . A
C . A.toString()
D . QUALITY.A
THE CORRECT ANSWER IS B.

47.
Which interface in the java.ul. function package can return a primitive type?
A . ToDoubleFuncon
B . Supplier
C . BiFunction
D . LongConsumer

THE CORRECT ANSWER IS A. Supplier and  BiFunction both return the specified type. and LongConsumer is void.

48.
GIVEN:

 public static void main(String[] args) throws IOException {
            final List<String> fruits = List.of("Orange", "Apple", "Lemmon", "Raspberry");
            final List<String> types =
                    List.of("Juice", "Pie", "Ice", "Tart");
            final var stream = IntStream.range(0, Math.min(fruits.size(), types.size()))
                    .mapToObj((i) -> fruits.get(i) + " " + types.get(i));
            stream.forEach(System.out::println);
}

What is the result?
A . Orange Juice
B . The compilation fails.
C . Orange Juice Apple Pie Lemmon Ice Raspberry Tart
D . The program prints nothing.

THE CORRECT ANSWER IS C.

49.
Which two statements correctly describe the capabilities of interfaces and abstract classes? (Choose two.)
A . Interfaces cannot have protected methods but abstract classes can.
B . Both interfaces and abstract classes can have final methods.
C . Interfaces cannot have instance fields but abstract classes can.
D . Interfaces cannot have static methods but abstract classes can.
E . Interfaces cannot have methods with bodies but abstract classes can.

THE CORRECT ANSWER IS A AND C.

50.
Which  annotation uses are valid? (Choose any.)
      A.  Function<String, String> func1 = (@NonNull x) -> x.toUpperCase();
      B.  var v = "Hello" + (@NonNull) "World";
      C.  Function<String, String> func2 = (var @NonNull x) -> x.toUpperCase();
      D.  Function<String, String> func3 = (@NonNull var x) -> x.toUpperCase();
      E.  var myString = (@NonNull String) str;
      F.  var obj =  new @NonNull   Teacher();
THE CORRECT ANSWER IS D.

51.
Consider this method declaration:
Void setSessionUser(Connection conn, String user) throws SQLException{
Statement stmt = conn.createStatement();
String sql = <EXPRESSION>;
stm

A) ''SET SESSION AUTHORIZATION '' + user
B) ''SET SESSION AUTHORIZATION '' + stmt.enquoteIdenfier(user)
Is A or B the correct replacement for <EXPRESSION> and why?
A . A, because it sends exactly the value of user provided by the calling code.
B . B, because enquong values provided by the calling code prevent SQL injection.
C . A and B are functionally equivalent.
D . A, because it is unnecessary to enclose identifiers in quotes.
E . B, because all values provided by the calling code should be enquoted.

THE CORRECT ANSWER IS B.

51.
Which two safely validate inputs? (Choose two.)
A . Delegate numeric range checking of values to the database.
B . Accept only valid characters and input values.
C . Use trusted domain-specific libraries to validate inputs.
D . Assume inputs have already been validated.
E . Modify the input values, as needed, to pass validaon.


THE CORRECT ANSWER IS B AND C.


52.
import java.util.*;

import static java.util.stream.Collectors.*;

class Sale {
    private String customer;
    private List<Book> items;
  //GETTER SETTER AND CONSTRUCTOR
   
}

class Book {
    private String name;
    private double price;

  //GETTER SETTER AND CONSTRUCTOR
}

Given a list of Sale objects, tList, which code fragment creates a list of total sales for each customer in
ascending order?

A.
 List<String> totalByUser = tList.stream()
                .collect(groupingBy(Sale::getCustomer,
                        flatMapping (t -> t.getItems().stream(),
                                summingDouble(Book::getPrice))))
                .entrySet().stream()
                .sorted(Comparator.comparing(Map.Entry::getValue))
                .collect(mapping (e -> e.getKey()+ ":"+ e.getValue(), toList()));

B.
List<String> totalByUser = totalByUser = tList.stream()
                .collect(flatMapping(t -> t.getItems().stream(),
                        groupingBy((Sale::getCustomer,
                                summingDouble(Book::getPrice))))
                .sorted(Comparator.comparing (Map.Entry::getValue))
                .collect(mapping(e -> e.getkey()+ ":"  + e.getValue(), toList()));

C.
   List<String> totalByUser = tList.stream()
                .collect(groupingBy(Sale::getCustomer,
                        flatMapping(t -> t.getItems().stream(),
                                summingDouble(Book::getPrice))))
                .sorted(Comparator.comparing(Map.Entery::getValue))
                .collect(mapping (e -> e.getKey() + ":" + e.getValue(), toList()));

D.
List<String> totalByUser = tList.stream()
                .collect(flatMapping (t -> t.getItems().stream(),
                        groupingBy(Sale::getCustomer,
                                summingDouble(Book::getPrice))))
                .entrySet().stream()
                .sorted(comperatorComparing(Entry::getValue))
                .collect(mapping (e -> e.getKey() + ":" + e.getValue(),  toList()));

THE CORRECT ANSWER IS A.

53.
Which two are secure serializaon of these objects? (Choose two.)
A . Define the serialPersistentFields array field.
B . Declare fields transient.
C . Implement only readResolve to replace the instance with a serial proxy and not writeReplace.
D . Make the class abstract.
E . Implement only writeReplace to replace the instance with a serial proxy and not readResolve

THE CORRECT ANSWER IS A AND B.

54.
Which two statements set the default locale used for formang numbers, currency, and percentages?
(Choose two.)
A . Locale.setDefault(Locale.Category.FORMAT, "zh-CN");
B . Locale.setDefault(Locale.Category.FORMAT, Locale.CANADA_FRENCH);
C . Locale.setDefault(Locale.SIMPLIFIED_CHINESE);
D . Locale.setDefault("en_CA");
E . Locale.setDefault("es", Locale.US);

THE CORRECT ANSWER IS B AND E.

55.
Given the code fragment:
var pool = Executors.newFixedThreadPool(5);
Future outcome = pool.submit(() > 1);
Which type of lambda expression is passed into submit()?
A . java.lang.Runnable
B . java.ul.function.Predicate
C . java.ul. function.Function
D . java.ul.concurrent.Callable

THE CORRECT ANSWER IS D. ////CAREFUL WITH WHAT IS BEEN PASSED AS METHOD ARUGUREMENT (submit()).  IF IT IS VOID THEN THE CALL IS Runnable otherwise it is Callable


56.
Given the code fragment:
var pool = Executors.newFixedThreadPool(5);
       Future outcome = pool.submit(() -> System.out.println());
Which type of lambda expression is passed into submit()?
A . java.lang.Runnable
B . java.ul.function.Predicate
C . java.ul. function.Function
D . java.ul.concurrent.Callable

THE CORRECT ANSWER IS A. //CAREFUL WITH WHAT IS BEEN PASSED AS METHOD ARUGUREMENT (submit()).  IF IT IS VOID THEN THE CALL IS Runnable otherwise it is Callable


57.
    public static void main(String[] args) {

        try (FileReader fileReader1 = new FileReader("file_to_path");
             FileReader fileReader2 = new FileReader("file_to_path");
             FileReader fileReader3 = new FileReader("file_to_path")) {

        } catch (IOException e) {
            e.printStackTrace();
        }
//        Line 1
        System.out.println("Done!");
}
When run and all three files exist, what is the state of each reader on Line 1?
A . All three readers are sll open.
B . All three readers have been closed.
C . The compilaon fails.
D . Only reader1 has been closed.

THE CORRECT ANSWER IS C. 

58.
Which three guidelines are used to protect confidenal informaon? (Choose three.)
A . Limit access to objects holding confidenal informaon.
B . Clearly idenfy and label confidenal informaon.
C . Manage confidenal and other informaon uniformly.
D . Transparently handle informaon to improve diagnoscs.
E . Treat user input as normal informaon.
F . Validate input before storing confidenal informaon.
G . Encapsulate confidenal informaon.

THE CORRECT ANSWER IS A, B, G.

58.
GIVEN: 

public class Person {
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>(List.of(new Person("Tom",101),
                new Person("Aman",102),
                new Person("Peter",102),
                new Person("James",101)));

        persons.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName).reversed());

        persons.forEach(System.out::println);
    }
}

A.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='James', age=101}

B.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='Tom', age=101}

C.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='Aman', age=101}

D.
Person{name='Peter', age=102}
Person{name='Tom', age=102}
Person{name='Aman', age=101}
Person{name='Peter', age=101}

THE CORRECT ANSWER IS A.

59.
GIVEN:

public class Person {
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;

    @Override
    public String toString() {
        return name
                ;
    }

    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>(List.of(new Person("Tom",102),
                new Person("Aman",102),
                new Person("Peter",102)));

        persons.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName).reversed());

        persons.forEach(System.out::println);
    }
}

A.
Aman
Peter
Tom

B.
Peter
Aman
Tom

C.
Tom
Aman
Peter

D.
Aman
Tom
Peter

THE CORRECT ANSWER IS A.

60.
Given: 

long count = persons.stream()
                // line 1
        System.out.println(count);

Which code, when inserted on line 1, prints the number of unique Names from the roster list?
A . .map(Person::getLocality) .distinct() .count();
B . map(e > e.getName()) .count();
C . .map(e > e.getName()) .collect(Collectors.toSet()) .count();
D . .filter(Person::getName) .distinct() .count();

THE CORRECT ANSWER IS A.

61.
Given:
public class Person {
    class Student{
        Student(String name){
       }
    }
    public static void main(String[] args) {
        var student = new Student("Hello");
    }
}

Which two independent changes will make the Main class compile? (Choose two.)
A . Move the entire Student class declaration to a separate Java file, Student.java.
B . Change line 2 to public Student(String name).
C . Change line 1 to public static class Student {.
D . Change line 3 to Student student = new Student(''Biology'');.
E . Change line 1 to stac class Student {.

THE CORRECT ANSWER IS A AND E.

62.
public class Main {
    public static void main(String[] args) {
        List<String> list1 = new LinkedList<String>();
        Set<String> hs1 = new HashSet<String>();
        String[] v = {"a", "b", "c", "b", "a"};
        for (String s : v) {
            list1.add(s);
            hs1.add(s);
        }


        System.out.print(hs1.size() + "" + list1.size() + " ");
        HashSet hs2 = new HashSet(list1);
        LinkedList list2 = new LinkedList(hs1);
        System.out.print(hs2.size() + "" + list2.size());
    }
}

What is the result?
A . 3 5 3 3
B . 3 3 3 3
C . 3 5 3 5
D . 5 5 3 3

THE CORRECT ANSWER IS A 

63.
GIVEN:

public class Main {

    public static void main(String[] args) {
        var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Optional<Integer> result = numbers.stream().filter(x -> x % 3 != 0).reduce((i, j) -> i + j);
        result.ifPresent(System.out::println); // line 1
    }
}

Which is true about line 1?
A . If the value is not present, a NoSuchElementExcepon is thrown at runTime.
B . It always executes the System.out::print statement.
C . If the value is not present, a NullPointerExcepon is thrown at runTime.
D . If the value is not present, nothing is done.

THE CORRECT ANSWER IS D. 

64.
GIVEN:

public class Main {
    public static void main(String[] args) {
        Integer [] intArray = {2,1,3,4,5};
        List<Integer> list = new ArrayList<>(Arrays.asList(intArray));
        list.parallelStream().forEach(e -> System.out.print(e + " "));
    }
}

Which two are correct? (Choose two.)
A . The output will be exactly 2 1 3 4 5.
B . The program prints 2 1 3 4 5. but the order is unpredictable.
C . Replacing forEach() with forEachOrdered(), the program prints 2 1 3 4 5, but the order is
unpredictable.
D . Replacing forEach() with forEachOrdered(), the program prints 1 2 3 4 5.
E . Replacing forEach() with forEachOrdered(), the program prints 2 1 3 4 5.

THE CORRECT ANSWER IS B AND E.


65.
Given:
class Secret{

    String names[];

    public Secret(String[] names){
        this.names = names;
    }

    public String[] getNames() {
        return names;
    }
}

Which three acons implement Java SE security guidelines? (Choose three.)
A . Change line 7 to return names.clone();.
B . Change line 4 to this.names = names.clone();.
C . Change the getNames() method name to get$Names().
D . Change line 6 to public synchronized String[] getNames() {.
E . Change line 2 to private final String[] names;.
F . Change line 3 to private Secret(String[] names) {.
G . Change line 2 to protected volale String[] names;.

THE CORRECT ANSWER IS A AND B AND E.

66.
Given:

public static void main(String[] args){
List<String> list1 = new ArrayList<>();
list1.add(''A'');
list1.add(''B'');
List list2 = List.copyOf(list1);
list2.add(''C'');
List<List<String>> list3 = List.of(list1, list2);
System.out.println(list3);

}

What is the result?
A . [[A, B],[A, B]]
B . An excepon is thrown at run me.
C . [[A, B], [A, B, C]]
D . [[A, B, C], [A, B, C]]

THE CORRECT ANSWER IS B.

67.
GIVEN:

public class Main {
    static void insertionSort(int values[]) {
        int n = values.length;
        for (int j = 1; j < n; j++) {
            int tmp = values[j];
            int i = j - 1;
            //Line 1
            while ((i > -1) && (values[i] > tmp)) {
                //Line 2
                values[i + 1] = values[i];
                i--;
                //Line 3
            }
            values[i + 1] = tmp;
            //Line 4
        }
    }

    public static void main(String[] args) {
        insertionSort(new int[]{4, 5, 2, 32, 342, 4});

    }
}
A . aer line 1
B . aer line 2
C . aer line 3
D . aer line 4

THE CORRECT ANSWER IS D.

68.
GIVEN: 
public class SerializeMessage implements Serializable {
    String message;
    LocalDateTime localDateTime;
    transient LocalDateTime updateDateTime;

    SerializeMessage(String message) {
        this.message = message;
        this.localDateTime = LocalDateTime.now();
    }

    public void readObject(ObjectInputStream in) {
        try {
            in.defaultReadObject();
            updateDateTime = LocalDateTime.now();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

When is the readObject method called?
A . before this object is deserialized
B . After this object is deserialized
C . before this object Is serialized
D . The method is never called.
E . After this object is serialized

THE CORRECT ANSWER IS B.

69.
Which is a proper JDBC URL?
A . jdbe.mysql.com://localhost:3306/database
B . hp://localhost.mysql.com:3306/database
C . hp://localhost mysql.jdbc:3306/database
D . jdbc:mysql://localhost:3306/database

THE CORRECT ANSWER IS D.

70.
GIVEN: 
public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .flatMapToInt(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 == 0))
                .peek(v -> System.out.print(v+""))
                .count();
        System.out.print(" " + count);
    }
}

What is the result?
A . 6910 3
B . 10126 3
C . 3
D . 6104 3

THE CORRECT ANSWER IS D.

71.
GIVEN:

public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .flatMapToInt(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 != 0))
                .peek(v -> System.out.print(v+""))
                .count();
        System.out.print(" " + count);
    }
}

What is the result?
A . 6910 3
B . 11913 3
C . 3
D . 6104 3

THE CORRECT ANSWER IS B.

71.
GIVEN:
public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .map(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 != 0))
                .peek(v -> System.out.print(v+" "))
                .count();
        System.out.print(" " + count);
    }
}
What is the result?
A . compilation error
B . 11913 3
C . 3
D . 6104 3
THE CORRECT ANSWER IS A. //  .map(n -> n +1) CAN'T add 1 to an object.

72.
GIVEN:
	 Consumer consumer = mess ->  System.out.print; // line 1
         consumer.accept("Hello lamda!");

This code results in a compilaon error.
Which code should be inserted on line 1 for a successful compilaon?
A . Consumer consumer = msg -> { return System.out.print(msg); };
B . Consumer consumer = var arg > {System.out.print(arg);};
C . Consumer consumer = (String args) > System.out.print(args);
D . Consumer consumer = System.out::print;

THE CORRECT ANSWER IS D.

73.
GIVEN:


public class Main {
    public static void main(String[] args) {
        String originalPath = "data\\projects\\a-project\\..\\..\\another-project";
        Path path = Paths.get(originalPath);
        System.out.println(path.normalize());
        System.out.println(path.toAbsolutePath());
    }
}
What is the result?
A . data\another-project
B . data\projects\a-project\another-project
C . data\\projects\\a-project\\..\\..\\another-project
D . data\projects\a-project\..\..\another-project

THE CORRECT ANSWER IS D.

74.
GIVEN:

A company has an exisng sales applicaon using a Java 8 jar file containing packages:
com.company.customer;
com.company.customer.orders;
com.company.customer.info;
com.company.sales;
com.company.sales.leads;
com.company.sales.closed;
com.company.orders;
com.company.orders.pending;
com.company.orders.shipped.
To modularize this jar file into three modules, customer, sales, and orders, which module-info.java
would be correct?

A. 
module com.company.customer {
    exports com.company.customer;
}
module com.company.sales {
    exports com.company.sales;
}
module com.company.orders {
    exports com.company.orders;
}

B.
module com.company.customer {
    opens com.company.customer;
}
module com.company.sales {
    opens com.company.sales;
}
module com.company.orders {
    opens com.company.orders;
}


C.
module com.company.customer {
    reqquires com.company.customer;
}
module com.company.sales {
    reqquires com.company.sales;
}
module com.company.orders {
    reqquires com.company.orders;
}


D.
module com.company.customer {
    provides com.company.customer;
}
module com.company.sales. {
    provides com.company.sales;
}
module com.company.orders {
    provides com.company.orders;
}

THE CORRECT ANSWER IS A

75. 
GIVEN:  

ON QUESTION 77.
