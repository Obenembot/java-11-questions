1.

public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. intstream.rangeclosed(l, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS D.

2.

interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


7. 

        Integer[] ints = {1,2,3,4,5,6,7};
        var list = Arrays.asList (ints);
        UnaryOperator<Integer> uo =  x -> x *  3; // line 11
        list.replaceAll (uo);

Which can replace line 11?
A . UnaryOperator<Interger > uo = (var x ) -> (x * 3);
B . UnaryOperator<Interger >uo = var x -> { return x 3 ; };
C . UnaryOperator<Interger >uo = x -> { return x * 3; };
D . UnaryOperator<Interger >uo = (int x) -> x * 3;

CORRECT ANSWER IS A AND C.

8.

GIVEN:

@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }
    String name() default "";
    Type type();
}

What is the correct definion of the JsonField annotaon that makes the Point class compile?

A. 
@Target(ElementType.FIELD)
public class Point {
    @JsonField(type = JsonField.Type.STRING)
    private String _name;

    @JsonField(type = JsonField.Type.INT)
    private int x;

    @JsonField(type = JsonField.Type.INT)
    private int y;
}

B.
@Target(ElementType.FIELD)
@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() ;

    Type type();
}

C.
@Target(ElementType.FIELD)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

D.
@Retention(RetentionPolicy.CLASS)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

CORRECT ANSWER IS A.

9.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes.isDirectory());
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . BasicFileAttributes attributes = Files.isDirectory(path);
B . BasicFileAttributes attributes =Files.getAribute (path, ''insdirectory'');
C . BasicFileAttributes attributes = Files.readAributes(path, BasicFileAributes.class);
D . BasicFileAttributes attributes = Files.readAributes(path, FileAributes.class);

CORRECT ANSWER IS C.

10.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . boolean attributes = Files.isDirectory(path);
B . boolean attributes =Files.getAribute (path, ''insdirectory'').isDirectory();
C . boolean attributes = Files.readAributes(path, BasicFileAributes.class).isDirectory();
D . boolean attributes = Files.readAributes(path, FileAributes.class).isDirectory();

CORRECT ANSWER IS A AND C.

11.
Given the code fragment:
public class Main {
    class L extends Exception {
    }

    class M extends L {
    }

    class N extends RuntimeException {
    }

    public void p() throws L {
        throw new M();
    }

    public void q() throws N {
        throw new N();
    }

    public static void main(String[] args) {

        try {
            Main main = new Main();
            main.p();
            main.q();
        } // Line 1
    }
}
What change on line 1 will make this code compile?

A . Add catch (L |N e).
B . Add catch (L |M N e).
C . Add catch (L e).
D . Add catch (N | L | M e).
E . Add catch (M |L e).

CORRECT ANSWER IS A AND C.

12.
Given the code fragment:

    public static void main(String[] args) {
        char arrays[] [] = {{'g', 'j'},{'h', 'k'}, {'i', 'l'}};
        for (char[] xx : arrays) {
            for (char yy : xx) {
                System.out.print(yy);
            }
            System.out.print(" ");
        }
    }

What is the result?

A . An ArrayIndexOutofBoundsExcepon is thrown at runme.
B . The compilaon fails.
C . gh ij kl
D . gj hk il
E . ghi jkl

CORRECT ANSWER IS D.

13.
Given:

public  interface AdaptorFirst {
    void showFirst();
}

Which three classes successfully override showFirst ()?

A. 
public abstract class Adaptor implements AdaptorFirst {
    public  String showFirst() {
        return "First";
    }
}

B.
public abstract class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

C.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() ;
}

D.
public  class Adaptor implements AdaptorFirst {
    private void showFirst() {
        System.out.println("First");
    }
}

E.
public abstract class Adaptor implements AdaptorFirst {
    public abstract void showFirst() ;
}

F.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

CORRECT ANSWER IS B AND E AND F.

14.


