1.
public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. intstream.rangeclosed(l, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS D.

2.
interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


7. 
        Integer[] ints = {1,2,3,4,5,6,7};
        var list = Arrays.asList (ints);
        UnaryOperator<Integer> uo =  x -> x *  3; // line 11
        list.replaceAll (uo);

Which can replace line 11?
A . UnaryOperator<Interger > uo = (var x ) -> (x * 3);
B . UnaryOperator<Interger >uo = var x -> { return x 3 ; };
C . UnaryOperator<Interger >uo = x -> { return x * 3; };
D . UnaryOperator<Interger >uo = (int x) -> x * 3;

CORRECT ANSWER IS A AND C.

8.

GIVEN:

@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }
    String name() default "";
    Type type();
}

What is the correct definion of the JsonField annotaon that makes the Point class compile?

A. 
@Target(ElementType.FIELD)
public class Point {
    @JsonField(type = JsonField.Type.STRING)
    private String _name;

    @JsonField(type = JsonField.Type.INT)
    private int x;

    @JsonField(type = JsonField.Type.INT)
    private int y;
}

B.
@Target(ElementType.FIELD)
@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() ;

    Type type();
}

C.
@Target(ElementType.FIELD)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

D.
@Retention(RetentionPolicy.CLASS)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

CORRECT ANSWER IS A.

9.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes.isDirectory());
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . BasicFileAttributes attributes = Files.isDirectory(path);
B . BasicFileAttributes attributes =Files.getAribute (path, ''insdirectory'');
C . BasicFileAttributes attributes = Files.readAributes(path, BasicFileAributes.class);
D . BasicFileAttributes attributes = Files.readAributes(path, FileAributes.class);

CORRECT ANSWER IS C.

10.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . boolean attributes = Files.isDirectory(path);
B . boolean attributes =Files.getAribute (path, ''insdirectory'').isDirectory();
C . boolean attributes = Files.readAributes(path, BasicFileAributes.class).isDirectory();
D . boolean attributes = Files.readAributes(path, FileAributes.class).isDirectory();

CORRECT ANSWER IS A AND C.

11.
Given the code fragment:
public class Main {
    class L extends Exception {
    }

    class M extends L {
    }

    class N extends RuntimeException {
    }

    public void p() throws L {
        throw new M();
    }

    public void q() throws N {
        throw new N();
    }

    public static void main(String[] args) {

        try {
            Main main = new Main();
            main.p();
            main.q();
        } // Line 1
    }
}
What change on line 1 will make this code compile?

A . Add catch (L |N e).
B . Add catch (L |M N e).
C . Add catch (L e).
D . Add catch (N | L | M e).
E . Add catch (M |L e).

CORRECT ANSWER IS A AND C.

12.
Given the code fragment:

    public static void main(String[] args) {
        char arrays[] [] = {{'g', 'j'},{'h', 'k'}, {'i', 'l'}};
        for (char[] xx : arrays) {
            for (char yy : xx) {
                System.out.print(yy);
            }
            System.out.print(" ");
        }
    }

What is the result?

A . An ArrayIndexOutofBoundsExcepon is thrown at runme.
B . The compilaon fails.
C . gh ij kl
D . gj hk il
E . ghi jkl

CORRECT ANSWER IS D.

13.
Given:
public  interface AdaptorFirst {
    void showFirst();
}

Which three classes successfully override showFirst ()?

A. 
public abstract class Adaptor implements AdaptorFirst {
    public  String showFirst() {
        return "First";
    }
}

B.
public abstract class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

C.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() ;
}

D.
public  class Adaptor implements AdaptorFirst {
    private void showFirst() {
        System.out.println("First");
    }
}

E.
public abstract class Adaptor implements AdaptorFirst {
    public abstract void showFirst() ;
}

F.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

CORRECT ANSWER IS B AND E AND F.

14.
GIVEN:
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner");
        private String type;

        private Machine(String type) {
            this.type = type; // line 1
        }

        private void setType(String type) {
            this.type = type; // line 2
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 3
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilaon fails due to an error on line 2.
D. The compilaon fails due to an error on line 1.
E. The compilaon fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS A.

15.
GIVEN: 
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner"); // line 1
        private String type;

        private void setType(String type) {
            this.type = type; // line 1
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 1
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}
What is the outcome? 

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilaon fails due to an error on line 2.
D. The compilaon fails due to an error on line 1.
E. The compilaon fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS D.

16.
GIVEN: 
public class Main {

    public static void main(String[] args) {
        StringBuilder text1 = new StringBuilder("PPQRRRSTT");
        int i = 0;
        a:
        while (i < text1.length()) {
            char x = text1.charAt(i);
            int j = 0;
            i++;
            b:
            while (j < text1.length()) {
                char y = text1.charAt(j);
                if (i != j && y == x) {
                    text1.deleteCharAt(j);
//line 1
                }
                j++;
            }
        }
        System.out.println(text1);
    }
}

Which two statements inserted independently at line 1 enable this code to print PRRT?
A . i--;
B . connue b;
C . break b;
D . j--;
E . connue a;
F . break a ;

CORRECT ANSWER IS C AND E.

17.
GIVEN: 
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}

What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilaon fails.
D . Keys: 0 Values: 0 Map: 2
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS F.

18.
GIVEN: 
public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}
What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS D.

19.
GIVEN: 
public class Main {
    static Map<String, String> map = new TreeMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real", "NOW"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
        System.out.println(map);
    }
}

What is the result?
A . {P=To, Q=Be, R=Real, S=NOW}
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . {S=Getting,P=To, Q=Be, R=Real}

CORRECT ANSWER IS A.

20.
GIVEN:
public class Main {
    public static void main(String[] args) {
        Consumer<String> c1 = arg -> System.out.println(arg);
        c1.accept("c1 Accepted");
        Consumer<String> c2 = arg -> System.out.println(arg);
        c2.accept("c2 Accepted");
        c2.andThen(c1).accept("c2 after");
        c2.accept("c2 Accepted Again");
    }
}

What is the result?
A. 
c1 Accepted
c2 Accepted
c2 after
c2 after
c2 Accepted Again

B.
c1 Accepted
c2 after
c2 Accepted Again

C.
c1 Accepted
c2 Accepted
c2 Accepted Again

D.
c2 Accepted
c2 after
c2 after
c2 Accepted Again

E.
c1 Accepted
c2 after
c2 after
c2 Accepted Again

CORRECT ANSWER IS A.

21:
GIVEN:

public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        Arrays.sort(towns, ms);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3

THE CORRECT ANSWER IS C. // NOT IF WHAT WE LOOKING FOR IS FOUND THEN IT RETURNS THE INDEX OF THAT ELEMENT.

22.
GIVEN:
public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3
THE CORRECT ANSWER IS D. // NOT BECAUSE WE DID NOT SORT, RETURNS THE INDEX BUT WITH A NEGATIVE.

23.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        p = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS C.

24.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        plant = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS A.

25.
GIVEN:
class Item {
    public String name;
    public int count;

    public Item(String name, int count) {
        this.name = name;
        this.count = count;
    }
}

public class Main {
    public static void main(String[] args) {
        var items = List.of(new Item("A", 15),
                new Item("B", 3),
                new Item("C", 12),
                new Item("D", 6));

// line 1
        System.out.println("Item for where count less than zero");
    }
}
}

You want to examine the items list it contains an item for which the variable count is below zero.
Which code fragment in line 1 accomplishes this?
A . if (items.stream() .filter(i -> i.count < 0).findFirst ()) {
B . if (items.stream () .filter (i -> i.count < 0) . findAny () ) {
C . if (items.stream () .allmatch (i -> count < 0) < 0) ) {
D . if (items.stream () .anymatch (i -> count < 0) < 0) ) {
E . if (items.stream().anyMatch(i -> i.count < 0 )) {

THE CORRECT ANSWER IS E.

26.
GIVEN:
public class ConSuper {
    protected ConSuper() {
        this(2);
        System.out.println("3");
    }

    protected ConSuper(int a) {
        System.out.println(a);
    }
}

public class ConSub extends ConSuper {
    ConSub() {
        this(4);
        System.out.println("1");
    }
    ConSub(int a) {
        System.out.println(a);
    }
    public static void main(String[] args) {
        new ConSub(4);
    }
}

What is the result?
A . 2134
B . 234
C . 2341
D . 214
THE CORRECT ANSWER IS B.

27.
GIVEN:
public class Main {
    public static void main(String[] args) {
        int i = 0;
        for (; i < 10; i++) {
            System.out.print(++i + " ");
        }
    }
}
What is the result?
A . 1 3 5 7 9
B . 1 3 5 7 9 11
C . 2 4 6 B 10
D . 2 4 6 8

THE CORRECT ANSWER IS A.


28.
public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(2,3,4);
        int sum = numbers.stream().reduce(0, (n, m) -> n + m);
        System.out.println(sum);
    }
}

What is the result?

You want to make the reduction operaon parallelized.
Which two modifications will accomplish this?
A . Replace line 1 with int sum = numbers. Stream (). Interate (0, a -> a+1. Reduce (0, (n m) -> n+m);
B . Replace line 1 with int sum = numbers. ParallelStream ( ). Reduce (0, (n, m ) -> n + m);
C . Replace line 1  with int sum = numbers. Parallel ( ). Stream ( ). Reduce (0, (n, m ) -> n + m);
D . Replace line 1 with int sum = numbers.stream().parallel().reduce(0, (n, m) -> n + m);
E . Replace line 1 with    int sum = numbers.parallelStream().reduce(0, (n, m) -> n + m);;

THE CORRECT ANSWER IS D AND E.

29.
 Which method throws an exception for not-a-number and infinite input values?
A). static float validation1 (String s) throws IllegalArgumentException {
return Float.parseFloat(s);
}
B). static float validation2 (String s, float min, float max) throws IllegalArgumentException {
Float f = Float. parseFloat(s);
}
C).  static float validation2 (String s, float min, float max) throws IllegalArgumentException {
float f = Float. parseFloat(s);
if(!Float.isFinite(f) || f > max){
throw new IllegalArgumentException();
}
Return f;
}
D).static float validation2 (String s, float min, float max) throws IllegalArgumentException{
Float f = Float. parseFloat(s);
if(Float.isFinite(f)  && f < min &&  f > max){
throw new IllegalArgumentException();
}
return f;
}

A . Option A
B. Option B
C. Option C
D. Option D
THE CORRECT ANSWER IS A.

30).
Given: 
public class Main{
private String[] strings =  {“ABCDEFGHIJKLMNOPQRSTUVWXYZ”,
“abcdefghijklmnopqrstuvwxyz”, “0123456789”};
public void write(String filename){
// line 1
for (String str: strings){
ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());
fileChannel.write(buffer);
}
}catch(IOException e){
e.printStackTrace();
}
}
public static void main(String[] args){
Main test = new Main();
Test.write(“file_to_path”);
}
}

You want to obtain the Filechannel object on line 1.
 Which code fragment will accomplish this?
A). try (FileChannel fineChannel = Channels.newChannel (new FileOutputStream(filename)); ){
}
B). try (FileChannel fineChannel =  new FileOutputStream(filename).getChannel()){
}
C). try(FileChannel fileChannel = new FileOutputStream(new FileChannel(filename)); ){
}
D). try(FileChannel fileChannel = new FileChannel (new FileoutputStream(filename)); ){
}

THE CORRECT ANSWER IS B.

31).  Given the code fragment:
8.          public class Test{
9.          private final int x = 1;
10.         static final int y;
11.          public Test() {
12.            System.out.print(x);
13.             System.out.print(y);
14.          } 
15.       public static void main(String[] args){
16.        new Test();
17.    }
18.}

What is the result?
A . 1
B . The compilation fails at line 
C. 10
D. The compilation fails at line 10.
E. The compilation fails at line 13.

THE CORRECT ANSWER IS D.

32.
GIVEN: 
final class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS A. // CAN NOT INHERIT FROM FINAL CLASS

33.
GIVEN: 
class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS D.

34.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            list1.sort((String item1, String item2) -> item1.compareTo(item2));
            list2.sort((String item1, String item2) -> item1.compareTo(item2));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS A.

35.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS A.

36.
Given the content:
MessagesBundle.properties file:
Username = Username
Password = Password
And 
MessagesBundle_fr_FR.properties file:
Username = utilisateur
password = Le passe
And 
MessagesBundle_ru.properties file
Username = Mark
Password = Tyson
And the code fragment:
public class Test{
public static void main(String[] args){
Locale.setDefault(Locale.FRANCE);
ResourceBundle msg = ResourceBundle.getBundle(“MessageBundle”, new Locale(“ru”));
System.out.println(“User ”+ msg.getString(“username”));
System.out.println(“Pass ”+ msg.getString(“password”));
    }
}
What is the result?
A). User = Mark
      Pass = Tyson
B). The compilation fails.
C). A missingResourceException is thrown at runtime.
D). User = Utilisateur
       Pass = Le Passe
E). User Username

THE CORRECT ANSWER IS C.

37.
Given Triple This =.java:
6. import java.util.function.*;
7. public TripleThis{
public static void main(String[] args){
  Function tripler = x -> { return (Integer) x * 3; };
TripleThis.printValue(tripler, 4);
}
public static <T> void printValue(Function f, T num){
System.out.println(f.apply(num));
}  }
Compiling TripleThis.java gives this compiler warning:
Note: TripleTHis.java uses unchecked or unsafe operations.
Which two replacements done together remove this compiler warning?
A . Replace line 9 with function<Integer> triple = x->-{return (Integer)x*3;}.
B. Replace line 12 with public static void printValue function<Integer> f, int num){.
C. Replace line 12 with public static int printValue function<Integer, Integer>, f, T num{.
D. Replace line 12 with public static <T> void privateValue(Function<T, T>f, T num){,
E. Replace line 9 with function<Integer>, Integer> = X -> {return (integer)x * 3; }.

THE CORRECT ANSWER IS D AND E.

38.
Given
public class Employee{
private String name;
private String neighborhood;
private LocalDate birthday;
private int salary;
} 
And 
List<Employee> roster = new ArrayList<>(…);
Map<String, Optional<Employee>> m = roster.stream()
  // Line 1
Which code fragment on line 1 makes the m map contain the employee with the highest salary for each neighborhood?
A).
.collect(Collectors.maxBy(Employee::getSalary, Collectors.groupingBy(Comparator.comparing(e -> e.getNeighborhood()))));
B).
.collect(Collectors.groupingBy(Employee::getNeighborhood, Collectors.maxBy(Comparator.comparing(Employee::getSalary))));
C). 
.collect(Collectors.groupingBy(e -> e.getNeighborhood(), Collectors.maxBy((x, y) -> y.getSalary() – x.getSalary() )));
D).
Collect(Collectors.maxBy(x, y) -> y.getSalary() – x.getSalary(),  Collectors.groupingBy(Employee::getNeighborhood)));

THE CORRECT ANSWER IS B. WATCH OUT FOR C AS WELL IF THE Y AND X AND INTERCHANGED.

39.
Given:
public class Main{ 
public static void main(String[] args){
List l = new ArrayList();
l.add(“hello”);
l.add(“world”);
print(1);
}
private static void print(List<String>… args){
for(List<String> str : args){
System.out.println(str);
       }
    } 
}

Which annotation should be used to removed warnings from complication?
	A.	@SuppressWarnings on the main and print methods
	B•	 @SuppressWarnings(''unchecked'') on main and @SafeVarargs on the print method
	C•	 @SuppressWarnings(''rawtypes'') on main and @SafeVarargs on the print method
	d•	 @SuppressWarnings(''all'') on the main and print methods

THE CORRECT ANSWER IS B.


40.
Given:
jdeps -jdkinternals C:\workspace4\SimpleSecurity\jar\classes.jar
Which describes the expected output?
A . jdeps lists the module dependencies and the package names of all referenced JDK internal APIs. If
any are found, the suggested replacements are output in the console.
B . jdeps outputs an error message that the -jdkinternals opon requires either the -summary or the -
verbose opons to output to the console.
C . The -jdkinternals opon analyzes all classes in the .jar and prints all class-level dependencies.
D . The -jdkinternals opon analyzes all classes in the .jar for class-level dependencies on JDK internal
APIs. If any are found, the results with suggested replacements are output in the console.

THE CORRECT ANSWER IS D.

Explanation:
-jdkinternals option analyzes all classes in the .jar for class-level dependencies on JDK internal APIs. If
any are found, the results with suggested replacements are output in the console

41.
Given:
List<String> longlist = List.of("HELLO", "WORLD","BEAT");
List shortList = new ArrayList<>();

Which code fragment correctly forms a short list of words containing the letter “E”?

A.	longlist.stream().
         filter(w ->  w.indexOf("E")  != -1)
                 .parallel()
                 .forEach(w -> shortList.add(w));
B.	longList.parallelStream()
        .filter(w ->  w.indexOf("E) != -1)
        .forEach(w -> shortList.add(w));

C.	shortList = longlist.stream()
    .filter(w ->  w.indexOf("E) != -1)
            .parallel()
        .collect(Collectors.toList());
D.	longlist.stream()
       .filter(w -> w.indexOf("E)  != -1)
        .parallel()
        .collect(shortList);


THE CORRECT ANSWER IS C AND B AND A.

42.
Given the code fragment:
Path source = Paths.get(''/repo/a/a.txt'');
Path desnaon = Paths.get(''/repo'');
Files.move(source, desnaon); // line 1
Files.delete (source); // line 2
Assuming the source file and desnaon folder exist, what Is the result?
A . A java.nio.file.FileAlreadyExistsExcepon is thrown on line 1.
B . A java.nio.file.NoSuchFileExcepon is thrown on line 2.
C . A copy of /repo/a/a.txt is moved to the /repo directory and /repo/a/a.txt is deleted.
D . a.txt is renamed repo.

THE CORRECT ANSWER IS A.

43.
enum Letter {
    ALPHA(100), BETA(200), GAMMA(300);
    int v;

    Letter(int v) {
    }
  // Line 1
}

Examine this code:
System.out.println(Leer.values()[1]);
What code should be wrien at line 5 for this code to print 200?
A . public String toString() { return String.valueOf(ALPHA.v); }
B . public String toString() { return String.valueOf(Leer.values()[1]); }
C . public String toString() { return String.valueOf(v); }
D . String toString() { return ''200''; }


THE CORRECT ANSWER IS B.
