1.
public class FizzBuzz {

    public static String convert(int x) {
        if (x % 15 == 0) {
            return "FizzBuzz";
        } else if ((x % 3 == 0)) {
            return "Fizz";
        } else if (x % 5 == 0) {
            return "Buzz";
        } else {
            return Integer.toString(x);
        }
    }

    public static void main(String[] args) {
       for (int i = 1; i < 101; i++) {
         System.out.println(convert(i));
       }
    }
}


Which code fragment replaces the for statement?
A. IntStream.rangeClosed(l, 100).map(FizzBuzz::convert).forEach(System.out::println);
B. IntStream.ranged, 100).map(FizzBuzz::convert).forEach(System.out::println);
C. IntStream.rangeClosed(1, 100).mapToObj{FizzBuzz::convert).forEach(System.out::printIn);
D. IntStream.range(1, 100).mapToObj(FizzBuzz::convert).forEach(System.out::println); 

CORRECT ANSWER IS C. WATCH OUT FOR map and convert(int x) method as it expects an int. 
// ranged start inclusive and end exclusive and rangeClosed start and end is inclusive

2.
interface Abacus {
    public int calc(int a, int b);
}

public class Main {
    public static void main(String[] args){
        int result = 0;
// LINE 1
        result = aba.calc(10,20);
        System.out.println(result);
    }
}

Which two codes, independently, can be inserted in LINE 1 compile?
A . Abacus aba = (int m, int n) -> { m * n };
B . Abacus aba = (int e, int f) -> { return e * f; };
C . Abacus aba = (a, b) -> a * b;
D . Abacus aba = v, w -> x * y;
E . Abacus aba = (int i, j) -> ( return i * j; };

CORRECT ANSWER IS B AND C.

3. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.


4. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        AbstractCopier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS A.

5. 
GIVEN: 

public interface Copier {
    public default void print(String sgm){
        System.out.println("Message from copier: " + sgm);
    }
}

public class AbstractCopier {
    protected void print(String load) {
        System.out.println("Message from Abstract Copier: " + load);
    }
}

public class TestImplementation  extends AbstractCopier implements  Copier{

 @Override
    public void print(String sgm) {
        Copier.super.print(sgm);
    }

    public static void main(String[] args){
        TestImplementation test  = new TestImplementation();
        test.print("Attempt000000");
    }
}

What is the output?
A . A compilaon error is thrown.
B . Message from Copier: Attempt000000
C . Message from Abstract Copier: Attempt000000
D . A runme error is thrown.

CORRECT ANSWER IS B.


6.
Your organizaon makes mlib.jar available to your cloud customers. While working on a code cleanup
project for mlib.jar, you see this method by customers

public class Main{
   private Socket transportSocket;

    public void enableService(String hostName, String portNumber) throws IOException {
        this.transportSocket = new Socket(hostName, Integer.parseInt(portNumber));

        transportSocket.close();
    }
}

What security measures should be added to this method so that it meets the requirements for a
customer accessible method?

A.   Insert this code before the call to new Socket
        hostName = new String(hostName);
        portNumber = new String(portNumber);

B . Create a method that validates the hostName and portNumber parameters before opening the
socket.
C . Make enableService private.
D . Enclose the call to new Socket In an AccessController.doPrivileged block.

CORRECT ANSWER IS D. 
MAKE SURE SOCKET ARE CLOSED.
public void enableService(String hostName, String portNumber) throws IOException {
    // Input validation
    if (!isValidHostName(hostName) || !isValidPort(portNumber)) {
        throw new IllegalArgumentException("Invalid hostName or portNumber");
    }

    // Create a socket and handle exceptions
    try (Socket socket = new Socket(hostName, Integer.parseInt(portNumber))) {
        // Do something with the socket if needed
        this.transportSocket = socket;
    } catch (IOException e) {
        // Properly handle exceptions (log, rethrow, or handle as needed)
        throw e;
    }
}

// Example of input validation methods
private boolean isValidHostName(String hostName) {
    // Implement hostName validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}

private boolean isValidPort(String portNumber) {
    // Implement portNumber validation logic
    // Return true if it's valid, false otherwise
    return true; // Replace with your validation code
}


7. 
        Integer[] ints = {1,2,3,4,5,6,7};
        var list = Arrays.asList (ints);
        UnaryOperator<Integer> uo =  x -> x *  3; // line 11
        list.replaceAll (uo);

Which can replace line 11?
A . UnaryOperator<Interger > uo = (var x ) -> (x * 3);
B . UnaryOperator<Interger >uo = var x -> { return x 3 ; };
C . UnaryOperator<Interger >uo = x -> { return x * 3; };
D . UnaryOperator<Interger >uo = (int x) -> x * 3;

CORRECT ANSWER IS A AND C.

8.

GIVEN:

@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }
    String name() default "";
    Type type();
}

What is the correct definion of the JsonField annotaon that makes the Point class compile?

A. 
@Target(ElementType.FIELD)
public class Point {
    @JsonField(type = JsonField.Type.STRING)
    private String _name;

    @JsonField(type = JsonField.Type.INT)
    private int x;

    @JsonField(type = JsonField.Type.INT)
    private int y;
}

B.
@Target(ElementType.FIELD)
@interface JsonField {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() ;

    Type type();
}

C.
@Target(ElementType.FIELD)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

D.
@Retention(RetentionPolicy.CLASS)
@interface JsonField1 {
    enum Type {
        INT, STRING, BOOLEAN
    }

    String name() default "";

    Type type();
}

CORRECT ANSWER IS A.

9.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes.isDirectory());
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . BasicFileAttributes attributes = Files.isDirectory(path);
B . BasicFileAttributes attributes =Files.getAribute (path, ''insdirectory'');
C . BasicFileAttributes attributes = Files.readAributes(path, BasicFileAributes.class);
D . BasicFileAttributes attributes = Files.readAributes(path, FileAributes.class);

CORRECT ANSWER IS C.

10.
Given the code fragment:

    public static void main(String[] args) {
        try {
            Path path = Paths.get("src/annotations");
//line 1
            System.out.println(attributes);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
You want to examine whether path is a directory.
Which code inserted on line 1 will accomplish this?

A . boolean attributes = Files.isDirectory(path);
B . boolean attributes =Files.getAribute (path, ''insdirectory'').isDirectory();
C . boolean attributes = Files.readAributes(path, BasicFileAributes.class).isDirectory();
D . boolean attributes = Files.readAributes(path, FileAributes.class).isDirectory();

CORRECT ANSWER IS A AND C.

11.
Given the code fragment:
public class Main {
    class L extends Exception {
    }

    class M extends L {
    }

    class N extends RuntimeException {
    }

    public void p() throws L {
        throw new M();
    }

    public void q() throws N {
        throw new N();
    }

    public static void main(String[] args) {

        try {
            Main main = new Main();
            main.p();
            main.q();
        } // Line 1
    }
}
What change on line 1 will make this code compile?

A . Add catch (L |N e).
B . Add catch (L |M N e).
C . Add catch (L e).
D . Add catch (N | L | M e).
E . Add catch (M |L e).

CORRECT ANSWER IS A AND C.

12.
Given the code fragment:

    public static void main(String[] args) {
        char arrays[] [] = {{'g', 'j'},{'h', 'k'}, {'i', 'l'}};
        for (char[] xx : arrays) {
            for (char yy : xx) {
                System.out.print(yy);
            }
            System.out.print(" ");
        }
    }

What is the result?

A . An ArrayIndexOutofBoundsExcepon is thrown at runme.
B . The compilaon fails.
C . gh ij kl
D . gj hk il
E . ghi jkl

CORRECT ANSWER IS D.

13.
Given:
public  interface AdaptorFirst {
    void showFirst();
}

Which three classes successfully override showFirst ()?

A. 
public abstract class Adaptor implements AdaptorFirst {
    public  String showFirst() {
        return "First";
    }
}

B.
public abstract class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

C.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() ;
}

D.
public  class Adaptor implements AdaptorFirst {
    private void showFirst() {
        System.out.println("First");
    }
}

E.
public abstract class Adaptor implements AdaptorFirst {
    public abstract void showFirst() ;
}

F.
public  class Adaptor implements AdaptorFirst {
    public void showFirst() {
        System.out.println("First");
    }
}

CORRECT ANSWER IS B AND E AND F.

14.
GIVEN:
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner");
        private String type;

        private Machine(String type) {
            this.type = type; // line 1
        }

        private void setType(String type) {
            this.type = type; // line 2
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 3
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilation fails due to an error on line 2.
D. The compilation fails due to an error on line 1.
E. The compilation fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS B.

15.
GIVEN: 
public class Main {
    enum Machine {
        AUTO("Vehicle"), MEDICAL("Scanner"); // line 1
        private String type;

        private void setType(String type) {
            this.type = type; // line 1
        }

        private String getType() {
            return type;
        }
    }

        public static void main(String[] args) {
            Machine.AUTO.setType("Toyota"); // line 1
            for (Machine machine : Machine.values()) {
                System.out.println(machine +": " + machine.getType());
            }
        }
}
What is the outcome? 

A. An exception is thrown at runtime.
B.  AUTO: Toyota
    MEDICAL: Scanner
C. The compilation fails due to an error on line 2.
D. The compilation fails due to an error on line 1.
E. The compilation fails due to an error on line 3
F. AUTO: Vehicle
   MEDICAL: Scanner

CORRECT ANSWER IS D.

16.
GIVEN: 
public class Main {

    public static void main(String[] args) {
        StringBuilder text1 = new StringBuilder("PPQRRRSTT");
        int i = 0;
        a:
        while (i < text1.length()) {
            char x = text1.charAt(i);
            int j = 0;
            i++;
            b:
            while (j < text1.length()) {
                char y = text1.charAt(j);
                if (i != j && y == x) {
                    text1.deleteCharAt(j);
//line 1
                }
                j++;
            }
        }
        System.out.println(text1);
    }
}

Which two statements inserted independently at line 1 enable this code to print PRRT?
A . i--;
B . connue b;
C . break b;
D . j--;
E . connue a;
F . break a ;

CORRECT ANSWER IS C AND E.

17.
GIVEN: 
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}

What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilaon fails.
D . Keys: 0 Values: 0 Map: 2
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS F.

18.
GIVEN: 
public class Main {
    static Map<String, String> map = new HashMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
    }
}
What is the result?
A . Keys: 4 Values: 4 Map: 0
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . Keys: 0 Values: 0 Map: 0
F . Keys: 0 Values: 0 Map: 4

CORRECT ANSWER IS D.

19.
GIVEN: 
public class Main {
    static Map<String, String> map = new TreeMap<>();
    static List<String> keys = new ArrayList<>(List.of("S", "P", "Q", "R", "S"));
    static String[] values = {"Getting", "To", "Be", "Real", "NOW"};
    static {
        for (var i = 0; i < keys.size(); i++) {
            map.put(keys.get(i), values[i]);
        }
    }
    public static void main(String[] args) {
        keys.clear();
        values = new String[0];
        System.out.println("Keys: " + keys.size() + " Values: " + values.length+
        " Map: " + map.size());
        System.out.println(map);
    }
}

What is the result?
A . {P=To, Q=Be, R=Real, S=NOW}
B . Keys: 4 Values: 4 Map: 4
C . The compilation fails.
D . Exception at runtime
E . {S=Getting,P=To, Q=Be, R=Real}

CORRECT ANSWER IS A.

20.
GIVEN:
public class Main {
    public static void main(String[] args) {
        Consumer<String> c1 = arg -> System.out.println(arg);
        c1.accept("c1 Accepted");
        Consumer<String> c2 = arg -> System.out.println(arg);
        c2.accept("c2 Accepted");
        c2.andThen(c1).accept("c2 after");
        c2.accept("c2 Accepted Again");
    }
}

What is the result?
A. 
c1 Accepted
c2 Accepted
c2 after
c2 after
c2 Accepted Again

B.
c1 Accepted
c2 after
c2 Accepted Again

C.
c1 Accepted
c2 Accepted
c2 Accepted Again

D.
c2 Accepted
c2 after
c2 after
c2 Accepted Again

E.
c1 Accepted
c2 after
c2 after
c2 Accepted Again

CORRECT ANSWER IS A.

21:
GIVEN:

public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        Arrays.sort(towns, ms);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3

THE CORRECT ANSWER IS C. // NOT IF WHAT WE LOOKING FOR IS FOUND THEN IT RETURNS THE INDEX OF THAT ELEMENT.

22.
GIVEN:
public class Main {
    public static void main(String[] args) {
        String[] towns = {"boston", "paris", "bangkok", "oman"};
        Comparator<String> ms = (a, b) -> b.compareTo(a);
        int oman = Arrays.binarySearch(towns, "oman", ms);
        System.out.println(oman);
    }
}

What is the result?
A . 2
B . -1
C . 1
D . -3
THE CORRECT ANSWER IS D. // NOT BECAUSE WE DID NOT SORT, RETURNS THE INDEX BUT WITH A NEGATIVE.

23.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        p = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS C.

24.
GIVEN:
class Plant {
}

class Tulip extends Plant {
}

public class Garden {
    private static Plant plant;

    public static void main(String[] args) {
        plant = new Tulip();
        feed(plant);
        feed(plant);
    }

    public static void feed(Plant p) {
        if (p instanceof Tulip) {
            System.out.print(" Be careful ");
        }
        plant = null;
    }
}

What is the result?
A . Be careful
B . The program prints nothing.
C . Be careful Be careful
D . An exception is thrown at runtime

THE CORRECT ANSWER IS A.

25.
GIVEN:
class Item {
    public String name;
    public int count;

    public Item(String name, int count) {
        this.name = name;
        this.count = count;
    }
}

public class Main {
    public static void main(String[] args) {
        var items = List.of(new Item("A", 15),
                new Item("B", 3),
                new Item("C", 12),
                new Item("D", 6));

// line 1
        System.out.println("Item for where count less than zero");
    }
}
}

You want to examine the items list it contains an item for which the variable count is below zero.
Which code fragment in line 1 accomplishes this?
A . if (items.stream() .filter(i -> i.count < 0).findFirst ()) {
B . if (items.stream () .filter (i -> i.count < 0) . findAny () ) {
C . if (items.stream () .allmatch (i -> count < 0) < 0) ) {
D . if (items.stream () .anymatch (i -> count < 0) < 0) ) {
E . if (items.stream().anyMatch(i -> i.count < 0 )) {

THE CORRECT ANSWER IS E.

26.
GIVEN:
public class ConSuper {
    protected ConSuper() {
        this(2);
        System.out.println("3");
    }

    protected ConSuper(int a) {
        System.out.println(a);
    }
}

public class ConSub extends ConSuper {
    ConSub() {
        this(4);
        System.out.println("1");
    }
    ConSub(int a) {
        System.out.println(a);
    }
    public static void main(String[] args) {
        new ConSub(4);
    }
}

What is the result?
A . 2134
B . 234
C . 2341
D . 214
THE CORRECT ANSWER IS B.

27.
GIVEN:
public class Main {
    public static void main(String[] args) {
        int i = 0;
        for (; i < 10; i++) {
            System.out.print(++i + " ");
        }
    }
}
What is the result?
A . 1 3 5 7 9
B . 1 3 5 7 9 11
C . 2 4 6 B 10
D . 2 4 6 8

THE CORRECT ANSWER IS A.


28.
public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(2,3,4);
        int sum = numbers.stream().reduce(0, (n, m) -> n + m);
        System.out.println(sum);
    }
}

What is the result?

You want to make the reduction operaon parallelized.
Which two modifications will accomplish this?
A . Replace line 1 with int sum = numbers. Stream (). Interate (0, a -> a+1. Reduce (0, (n m) -> n+m);
B . Replace line 1 with int sum = numbers. ParallelStream ( ). Reduce (0, (n, m ) -> n + m);
C . Replace line 1  with int sum = numbers. Parallel ( ). Stream ( ). Reduce (0, (n, m ) -> n + m);
D . Replace line 1 with int sum = numbers.stream().parallel().reduce(0, (n, m) -> n + m);
E . Replace line 1 with    int sum = numbers.parallelStream().reduce(0, (n, m) -> n + m);;

THE CORRECT ANSWER IS D AND E.

29.
 Which method throws an exception for not-a-number and infinite input values?
A). static float validation1 (String s) throws IllegalArgumentException {
return Float.parseFloat(s);
}
B). static float validation2 (String s, float min, float max) throws IllegalArgumentException {
Float f = Float. parseFloat(s);
}
C).  static float validation2 (String s, float min, float max) throws IllegalArgumentException {
float f = Float. parseFloat(s);
if(!Float.isFinite(f) || f > max){
throw new IllegalArgumentException();
}
Return f;
}
D).static float validation2 (String s, float min, float max) throws IllegalArgumentException{
Float f = Float. parseFloat(s);
if(Float.isFinite(f)  && f < min &&  f > max){
throw new IllegalArgumentException();
}
return f;
}

A . Option A
B. Option B
C. Option C
D. Option D
THE CORRECT ANSWER IS A.

30).
Given: 
public class Main{
private String[] strings =  {“ABCDEFGHIJKLMNOPQRSTUVWXYZ”,
“abcdefghijklmnopqrstuvwxyz”, “0123456789”};
public void write(String filename){
// line 1
for (String str: strings){
ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());
fileChannel.write(buffer);
}
}catch(IOException e){
e.printStackTrace();
}
}
public static void main(String[] args){
Main test = new Main();
Test.write(“file_to_path”);
}
}

You want to obtain the Filechannel object on line 1.
 Which code fragment will accomplish this?
A). try (FileChannel fineChannel = Channels.newChannel (new FileOutputStream(filename)); ){
}
B). try (FileChannel fineChannel =  new FileOutputStream(filename).getChannel()){
}
C). try(FileChannel fileChannel = new FileOutputStream(new FileChannel(filename)); ){
}
D). try(FileChannel fileChannel = new FileChannel (new FileoutputStream(filename)); ){
}

THE CORRECT ANSWER IS B.

31).  Given the code fragment:
8.          public class Test{
9.          private final int x = 1;
10.         static final int y;
11.          public Test() {
12.            System.out.print(x);
13.             System.out.print(y);
14.          } 
15.       public static void main(String[] args){
16.        new Test();
17.    }
18.}

What is the result?
A . 1
B . The compilation fails at line 
C. 10
D. The compilation fails at line 10.
E. The compilation fails at line 13.

THE CORRECT ANSWER IS D.

32.
GIVEN: 
final class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS A. // CAN NOT INHERIT FROM FINAL CLASS

33.
GIVEN: 
class X {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getName();
    }
}

class Y extends X {
    public Y(String name) {
        super();
        setName(name);
    }

    public static void main(String... args) {
        Y y = new Y("HH");
        System.out.println(y);
    }
}

What is the result?
A . The compilaon fails.
B . Y@<< hashcode>>
C . Null
D . HH

THE CORRECT ANSWER IS D.

34.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            list1.sort((String item1, String item2) -> item1.compareTo(item2));
            list2.sort((String item1, String item2) -> item1.compareTo(item2));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS B.

35.
Given the code fragment:
    public static void main(String... args) {
            List<String> list1 = new ArrayList<>(
                    List.of("Plane",  "Automobile", "Motorcycle"));
            List<String> list2 = new ArrayList<>(List.copyOf(list1));
            System.out.println(list1.equals(list2));
    }

What is the result?
A . A java.lang, UnsupportedOperaonExcepon is thrown.
B . True
C . False
D . A java.lang.NullPointerExcepon is thrown

THE CORRECT ANSWER IS A.

36.
Given the content:
MessagesBundle.properties file:
Username = Username
Password = Password
And 
MessagesBundle_fr_FR.properties file:
Username = utilisateur
password = Le passe
And 
MessagesBundle_ru.properties file
Username = Mark
Password = Tyson
And the code fragment:
public class Test{
public static void main(String[] args){
Locale.setDefault(Locale.FRANCE);
ResourceBundle msg = ResourceBundle.getBundle(“MessageBundle”, new Locale(“ru”));
System.out.println(“User ”+ msg.getString(“username”));
System.out.println(“Pass ”+ msg.getString(“password”));
    }
}
What is the result?
A). User = Mark
      Pass = Tyson
B). The compilation fails.
C). A missingResourceException is thrown at runtime.
D). User = Utilisateur
       Pass = Le Passe
E). User Username

THE CORRECT ANSWER IS C.

37.
Given Triple This =.java:
6. import java.util.function.*;
7. public TripleThis{
public static void main(String[] args){
  Function tripler = x -> { return (Integer) x * 3; };
TripleThis.printValue(tripler, 4);
}
public static <T> void printValue(Function f, T num){
System.out.println(f.apply(num));
}  }
Compiling TripleThis.java gives this compiler warning:
Note: TripleTHis.java uses unchecked or unsafe operations.
Which two replacements done together remove this compiler warning?
A . Replace line 9 with function<Integer> triple = x->-{return (Integer)x*3;}.
B. Replace line 12 with public static void printValue function<Integer> f, int num){.
C. Replace line 12 with public static int printValue function<Integer, Integer>, f, T num{.
D. Replace line 12 with public static <T> void privateValue(Function<T, T>f, T num){,
E. Replace line 9 with function<Integer>, Integer> = X -> {return (integer)x * 3; }.

THE CORRECT ANSWER IS D AND E.

38.
Given
public class Employee{
private String name;
private String neighborhood;
private LocalDate birthday;
private int salary;
} 
And 
List<Employee> roster = new ArrayList<>(…);
Map<String, Optional<Employee>> m = roster.stream()
  // Line 1
Which code fragment on line 1 makes the m map contain the employee with the highest salary for each neighborhood?
A).
.collect(Collectors.maxBy(Employee::getSalary, Collectors.groupingBy(Comparator.comparing(e -> e.getNeighborhood()))));
B).
.collect(Collectors.groupingBy(Employee::getNeighborhood, Collectors.maxBy(Comparator.comparing(Employee::getSalary))));
C). 
.collect(Collectors.groupingBy(e -> e.getNeighborhood(), Collectors.maxBy((x, y) -> y.getSalary() – x.getSalary() )));
D).
Collect(Collectors.maxBy(x, y) -> y.getSalary() – x.getSalary(),  Collectors.groupingBy(Employee::getNeighborhood)));

THE CORRECT ANSWER IS B. WATCH OUT FOR C AS WELL IF THE Y AND X AND INTERCHANGED.

39.
Given:
public class Main{ 
public static void main(String[] args){
List l = new ArrayList();
l.add(“hello”);
l.add(“world”);
print(1);
}
private static void print(List<String>… args){
for(List<String> str : args){
System.out.println(str);
       }
    } 
}

Which annotation should be used to removed warnings from complication?
	A.	@SuppressWarnings on the main and print methods
	B•	 @SuppressWarnings(''unchecked'') on main and @SafeVarargs on the print method
	C•	 @SuppressWarnings(''rawtypes'') on main and @SafeVarargs on the print method
	d•	 @SuppressWarnings(''all'') on the main and print methods

THE CORRECT ANSWER IS B.


40.
Given:
jdeps -jdkinternals C:\workspace4\SimpleSecurity\jar\classes.jar
Which describes the expected output?
A . jdeps lists the module dependencies and the package names of all referenced JDK internal APIs. If
any are found, the suggested replacements are output in the console.
B . jdeps outputs an error message that the -jdkinternals opon requires either the -summary or the -
verbose opons to output to the console.
C . The -jdkinternals opon analyzes all classes in the .jar and prints all class-level dependencies.
D . The -jdkinternals opon analyzes all classes in the .jar for class-level dependencies on JDK internal
APIs. If any are found, the results with suggested replacements are output in the console.

THE CORRECT ANSWER IS D.

Explanation:
-jdkinternals option analyzes all classes in the .jar for class-level dependencies on JDK internal APIs. If
any are found, the results with suggested replacements are output in the console

41.
Given:
List<String> longlist = List.of("HELLO", "WORLD","BEAT");
List shortList = new ArrayList<>();

Which code fragment correctly forms a short list of words containing the letter “E”?

A.	longlist.stream().
         filter(w ->  w.indexOf("E")  != -1)
                 .parallel()
                 .forEach(w -> shortList.add(w));
B.	longList.parallelStream()
        .filter(w ->  w.indexOf("E) != -1)
        .forEach(w -> shortList.add(w));

C.	shortList = longlist.stream()
    .filter(w ->  w.indexOf("E) != -1)
            .parallel()
        .collect(Collectors.toList());
D.	longlist.stream()
       .filter(w -> w.indexOf("E)  != -1)
        .parallel()
        .collect(shortList);


THE CORRECT ANSWER IS C AND B AND A.

42.
Given the code fragment:
Path source = Paths.get(''/repo/a/a.txt'');
Path desnaon = Paths.get(''/repo'');
Files.move(source, desnaon); // line 1
Files.delete (source); // line 2
Assuming the source file and desnaon folder exist, what Is the result?
A . A java.nio.file.FileAlreadyExistsExcepon is thrown on line 1.
B . A java.nio.file.NoSuchFileExcepon is thrown on line 2.
C . A copy of /repo/a/a.txt is moved to the /repo directory and /repo/a/a.txt is deleted.
D . a.txt is renamed repo.

THE CORRECT ANSWER IS A.

43.
enum Letter {
    ALPHA(100), BETA(200), GAMMA(300);
    int v;

    Letter(int v) {
    }
  // Line 1
}

Examine this code:
System.out.println(Leer.values()[1]);
What code should be wrien at line 5 for this code to print 200?
A . public String toString() { return String.valueOf(ALPHA.v); }
B . public String toString() { return String.valueOf(Leer.values()[1]); }
C . public String toString() { return String.valueOf(v); }
D . String toString() { return ''200''; }


THE CORRECT ANSWER IS B.

44.
Which two statements independently compile? (Choose two.)

A. List<? super Short> list1 = new ArrayList<Number>();
B. List<? extends Number> list3 = new ArrayList<Byte>();
C. List<? super Number> list2 = new ArrayList<Integer>();
D. List<? extends Number> list4 = new ArrayList<Object>();
E. List<? super Float> list5 = new ArrayList<Double>();

THE CORRECT ANSWER IS A AND B.

45.
Given:
LocalDate d1 = LocalDate.of(1997,2,7);
DateTimeFormaer d =
DateTimeFormaer.ofPaern( /*insert code here*/ );
System.out.println(d.format (d1));
Which paern formats the date as Friday 7th of February 1997?
A . ''eeee dd+''th of''+ MMM yyyy''
B . ''eeee dd'th of' MMM yyyy''
C . ''eeee d+''th of''+ MMMM yyyy''
D . ''eeee d'th of' MMMM yyyy''

THE CORRECT ANSWER IS D.


46.
enum QUALITY {
    A(1000), B(75), C(50);
    int percent;

    private QUALITY(int present) {
        this.percent = percent;
    }
    void checkQuality(QUALITY q) {
        switch(q) {
            case  //* Insert code here */:
                
                System.out.println("Best");
                Default:
                System.out.println("Not best");
            break;
        }
    }
}

Which code fragment can be inserted into the switch statement to print Best?
A . QUALITY.A.ValueOf()
B . A
C . A.toString()
D . QUALITY.A
THE CORRECT ANSWER IS B.

47.
Which interface in the java.ul. function package can return a primitive type?
A . ToDoubleFuncon
B . Supplier
C . BiFunction
D . LongConsumer

THE CORRECT ANSWER IS A. Supplier and  BiFunction both return the specified type. and LongConsumer is void.

48.
GIVEN:

 public static void main(String[] args) throws IOException {
            final List<String> fruits = List.of("Orange", "Apple", "Lemmon", "Raspberry");
            final List<String> types =
                    List.of("Juice", "Pie", "Ice", "Tart");
            final var stream = IntStream.range(0, Math.min(fruits.size(), types.size()))
                    .mapToObj((i) -> fruits.get(i) + " " + types.get(i));
            stream.forEach(System.out::println);
}

What is the result?
A . Orange Juice
B . The compilation fails.
C . Orange Juice Apple Pie Lemmon Ice Raspberry Tart
D . The program prints nothing.

THE CORRECT ANSWER IS C.

49.
Which two statements correctly describe the capabilities of interfaces and abstract classes? (Choose two.)
A . Interfaces cannot have protected methods but abstract classes can.
B . Both interfaces and abstract classes can have final methods.
C . Interfaces cannot have instance fields but abstract classes can.
D . Interfaces cannot have static methods but abstract classes can.
E . Interfaces cannot have methods with bodies but abstract classes can.

THE CORRECT ANSWER IS A AND C.

50.
Which  annotation uses are valid? (Choose any.)
      A.  Function<String, String> func1 = (@NonNull x) -> x.toUpperCase();
      B.  var v = "Hello" + (@NonNull) "World";
      C.  Function<String, String> func2 = (var @NonNull x) -> x.toUpperCase();
      D.  Function<String, String> func3 = (@NonNull var x) -> x.toUpperCase();
      E.  var myString = (@NonNull String) str;
      F.  var obj =  new @NonNull   Teacher();
THE CORRECT ANSWER IS D.

51.
Consider this method declaration:
Void setSessionUser(Connection conn, String user) throws SQLException{
Statement stmt = conn.createStatement();
String sql = <EXPRESSION>;
stm

A) ''SET SESSION AUTHORIZATION '' + user
B) ''SET SESSION AUTHORIZATION '' + stmt.enquoteIdenfier(user)
Is A or B the correct replacement for <EXPRESSION> and why?
A . A, because it sends exactly the value of user provided by the calling code.
B . B, because enquong values provided by the calling code prevent SQL injection.
C . A and B are functionally equivalent.
D . A, because it is unnecessary to enclose identifiers in quotes.
E . B, because all values provided by the calling code should be enquoted.

THE CORRECT ANSWER IS B.

51.
Which two safely validate inputs? (Choose two.)
A . Delegate numeric range checking of values to the database.
B . Accept only valid characters and input values.
C . Use trusted domain-specific libraries to validate inputs.
D . Assume inputs have already been validated.
E . Modify the input values, as needed, to pass validaon.


THE CORRECT ANSWER IS B AND C.


52.
import java.util.*;

import static java.util.stream.Collectors.*;

class Sale {
    private String customer;
    private List<Book> items;
  //GETTER SETTER AND CONSTRUCTOR
   
}

class Book {
    private String name;
    private double price;

  //GETTER SETTER AND CONSTRUCTOR
}

Given a list of Sale objects, tList, which code fragment creates a list of total sales for each customer in
ascending order?

A.
 List<String> totalByUser = tList.stream()
                .collect(groupingBy(Sale::getCustomer,
                        flatMapping (t -> t.getItems().stream(),
                                summingDouble(Book::getPrice))))
                .entrySet().stream()
                .sorted(Comparator.comparing(Map.Entry::getValue))
                .collect(mapping (e -> e.getKey()+ ":"+ e.getValue(), toList()));

B.
List<String> totalByUser = totalByUser = tList.stream()
                .collect(flatMapping(t -> t.getItems().stream(),
                        groupingBy((Sale::getCustomer,
                                summingDouble(Book::getPrice))))
                .sorted(Comparator.comparing (Map.Entry::getValue))
                .collect(mapping(e -> e.getkey()+ ":"  + e.getValue(), toList()));

C.
   List<String> totalByUser = tList.stream()
                .collect(groupingBy(Sale::getCustomer,
                        flatMapping(t -> t.getItems().stream(),
                                summingDouble(Book::getPrice))))
                .sorted(Comparator.comparing(Map.Entery::getValue))
                .collect(mapping (e -> e.getKey() + ":" + e.getValue(), toList()));

D.
List<String> totalByUser = tList.stream()
                .collect(flatMapping (t -> t.getItems().stream(),
                        groupingBy(Sale::getCustomer,
                                summingDouble(Book::getPrice))))
                .entrySet().stream()
                .sorted(comperatorComparing(Entry::getValue))
                .collect(mapping (e -> e.getKey() + ":" + e.getValue(),  toList()));

THE CORRECT ANSWER IS A.

53.
Which two are secure serializaon of these objects? (Choose two.)
A . Define the serialPersistentFields array field.
B . Declare fields transient.
C . Implement only readResolve to replace the instance with a serial proxy and not writeReplace.
D . Make the class abstract.
E . Implement only writeReplace to replace the instance with a serial proxy and not readResolve

THE CORRECT ANSWER IS A AND B.

54.
Which two statements set the default locale used for formang numbers, currency, and percentages?
(Choose two.)
A . Locale.setDefault(Locale.Category.FORMAT, "zh-CN");
B . Locale.setDefault(Locale.Category.FORMAT, Locale.CANADA_FRENCH);
C . Locale.setDefault(Locale.SIMPLIFIED_CHINESE);
D . Locale.setDefault("en_CA");
E . Locale.setDefault("es", Locale.US);

THE CORRECT ANSWER IS B AND E.

55.
Given the code fragment:
var pool = Executors.newFixedThreadPool(5);
Future outcome = pool.submit(() > 1);
Which type of lambda expression is passed into submit()?
A . java.lang.Runnable
B . java.ul.function.Predicate
C . java.ul. function.Function
D . java.ul.concurrent.Callable

THE CORRECT ANSWER IS D. ////CAREFUL WITH WHAT IS BEEN PASSED AS METHOD ARUGUREMENT (submit()).  IF IT IS VOID THEN THE CALL IS Runnable otherwise it is Callable


56.
Given the code fragment:
var pool = Executors.newFixedThreadPool(5);
       Future outcome = pool.submit(() -> System.out.println());
Which type of lambda expression is passed into submit()?
A . java.lang.Runnable
B . java.ul.function.Predicate
C . java.ul. function.Function
D . java.ul.concurrent.Callable

THE CORRECT ANSWER IS A. //CAREFUL WITH WHAT IS BEEN PASSED AS METHOD ARUGUREMENT (submit()).  IF IT IS VOID THEN THE CALL IS Runnable otherwise it is Callable


57.
    public static void main(String[] args) {

        try (FileReader fileReader1 = new FileReader("file_to_path");
             FileReader fileReader2 = new FileReader("file_to_path");
             FileReader fileReader3 = new FileReader("file_to_path")) {

        } catch (IOException e) {
            e.printStackTrace();
        }
//        Line 1
        System.out.println("Done!");
}
When run and all three files exist, what is the state of each reader on Line 1?
A . All three readers are sll open.
B . All three readers have been closed.
C . The compilaon fails.
D . Only reader1 has been closed.

THE CORRECT ANSWER IS C. 

58.
Which three guidelines are used to protect confidenal informaon? (Choose three.)
A . Limit access to objects holding confidenal informaon.
B . Clearly idenfy and label confidenal informaon.
C . Manage confidenal and other informaon uniformly.
D . Transparently handle informaon to improve diagnoscs.
E . Treat user input as normal informaon.
F . Validate input before storing confidenal informaon.
G . Encapsulate confidenal informaon.

THE CORRECT ANSWER IS A, B, G.

58.
GIVEN: 

public class Person {
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>(List.of(new Person("Tom",101),
                new Person("Aman",102),
                new Person("Peter",102),
                new Person("James",101)));

        persons.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName).reversed());

        persons.forEach(System.out::println);
    }
}

A.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='James', age=101}

B.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='Tom', age=101}

C.
Person{name='Peter', age=102}
Person{name='Aman', age=102}
Person{name='Tom', age=101}
Person{name='Aman', age=101}

D.
Person{name='Peter', age=102}
Person{name='Tom', age=102}
Person{name='Aman', age=101}
Person{name='Peter', age=101}

THE CORRECT ANSWER IS A.

59.
GIVEN:

public class Person {
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;

    @Override
    public String toString() {
        return name
                ;
    }

    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>(List.of(new Person("Tom",102),
                new Person("Aman",102),
                new Person("Peter",102)));

        persons.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName).reversed());

        persons.forEach(System.out::println);
    }
}

A.
Aman
Peter
Tom

B.
Peter
Aman
Tom

C.
Tom
Aman
Peter

D.
Aman
Tom
Peter

THE CORRECT ANSWER IS A.

60.
Given: 

long count = persons.stream()
                // line 1
        System.out.println(count);

Which code, when inserted on line 1, prints the number of unique Names from the roster list?
A . .map(Person::getLocality) .distinct() .count();
B . map(e > e.getName()) .count();
C . .map(e > e.getName()) .collect(Collectors.toSet()) .count();
D . .filter(Person::getName) .distinct() .count();

THE CORRECT ANSWER IS A.

61.
Given:
public class Person {
    class Student{
        Student(String name){
       }
    }
    public static void main(String[] args) {
        var student = new Student("Hello");
    }
}

Which two independent changes will make the Main class compile? (Choose two.)
A . Move the entire Student class declaration to a separate Java file, Student.java.
B . Change line 2 to public Student(String name).
C . Change line 1 to public static class Student {.
D . Change line 3 to Student student = new Student(''Biology'');.
E . Change line 1 to stac class Student {.

THE CORRECT ANSWER IS A AND E.

62.
public class Main {
    public static void main(String[] args) {
        List<String> list1 = new LinkedList<String>();
        Set<String> hs1 = new HashSet<String>();
        String[] v = {"a", "b", "c", "b", "a"};
        for (String s : v) {
            list1.add(s);
            hs1.add(s);
        }


        System.out.print(hs1.size() + "" + list1.size() + " ");
        HashSet hs2 = new HashSet(list1);
        LinkedList list2 = new LinkedList(hs1);
        System.out.print(hs2.size() + "" + list2.size());
    }
}

What is the result?
A . 3 5 3 3
B . 3 3 3 3
C . 3 5 3 5
D . 5 5 3 3

THE CORRECT ANSWER IS A 

63.
GIVEN:

public class Main {

    public static void main(String[] args) {
        var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Optional<Integer> result = numbers.stream().filter(x -> x % 3 != 0).reduce((i, j) -> i + j);
        result.ifPresent(System.out::println); // line 1
    }
}

Which is true about line 1?
A . If the value is not present, a NoSuchElementExcepon is thrown at runTime.
B . It always executes the System.out::print statement.
C . If the value is not present, a NullPointerExcepon is thrown at runTime.
D . If the value is not present, nothing is done.

THE CORRECT ANSWER IS D. 

64.
GIVEN:

public class Main {
    public static void main(String[] args) {
        Integer [] intArray = {2,1,3,4,5};
        List<Integer> list = new ArrayList<>(Arrays.asList(intArray));
        list.parallelStream().forEach(e -> System.out.print(e + " "));
    }
}

Which two are correct? (Choose two.)
A . The output will be exactly 2 1 3 4 5.
B . The program prints 2 1 3 4 5. but the order is unpredictable.
C . Replacing forEach() with forEachOrdered(), the program prints 2 1 3 4 5, but the order is
unpredictable.
D . Replacing forEach() with forEachOrdered(), the program prints 1 2 3 4 5.
E . Replacing forEach() with forEachOrdered(), the program prints 2 1 3 4 5.

THE CORRECT ANSWER IS B AND E.


65.
Given:
class Secret{

    String names[];

    public Secret(String[] names){
        this.names = names;
    }

    public String[] getNames() {
        return names;
    }
}

Which three acons implement Java SE security guidelines? (Choose three.)
A . Change line 7 to return names.clone();.
B . Change line 4 to this.names = names.clone();.
C . Change the getNames() method name to get$Names().
D . Change line 6 to public synchronized String[] getNames() {.
E . Change line 2 to private final String[] names;.
F . Change line 3 to private Secret(String[] names) {.
G . Change line 2 to protected volale String[] names;.

THE CORRECT ANSWER IS A AND B AND E.

66.
Given:

public static void main(String[] args){
List<String> list1 = new ArrayList<>();
list1.add(''A'');
list1.add(''B'');
List list2 = List.copyOf(list1);
list2.add(''C'');
List<List<String>> list3 = List.of(list1, list2);
System.out.println(list3);

}

What is the result?
A . [[A, B],[A, B]]
B . An excepon is thrown at run me.
C . [[A, B], [A, B, C]]
D . [[A, B, C], [A, B, C]]

THE CORRECT ANSWER IS B.

67.
GIVEN:

public class Main {
    static void insertionSort(int values[]) {
        int n = values.length;
        for (int j = 1; j < n; j++) {
            int tmp = values[j];
            int i = j - 1;
            //Line 1
            while ((i > -1) && (values[i] > tmp)) {
                //Line 2
                values[i + 1] = values[i];
                i--;
                //Line 3
            }
            values[i + 1] = tmp;
            //Line 4
        }
    }

    public static void main(String[] args) {
        insertionSort(new int[]{4, 5, 2, 32, 342, 4});

    }
}
A . aer line 1
B . aer line 2
C . aer line 3
D . aer line 4

THE CORRECT ANSWER IS D.

68.
GIVEN: 
public class SerializeMessage implements Serializable {
    String message;
    LocalDateTime localDateTime;
    transient LocalDateTime updateDateTime;

    SerializeMessage(String message) {
        this.message = message;
        this.localDateTime = LocalDateTime.now();
    }

    public void readObject(ObjectInputStream in) {
        try {
            in.defaultReadObject();
            updateDateTime = LocalDateTime.now();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

When is the readObject method called?
A . before this object is deserialized
B . After this object is deserialized
C . before this object Is serialized
D . The method is never called.
E . After this object is serialized

THE CORRECT ANSWER IS B.

69.
Which is a proper JDBC URL?
A . jdbe.mysql.com://localhost:3306/database
B . hp://localhost.mysql.com:3306/database
C . hp://localhost mysql.jdbc:3306/database
D . jdbc:mysql://localhost:3306/database

THE CORRECT ANSWER IS D.

70.
GIVEN: 
public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .flatMapToInt(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 == 0))
                .peek(v -> System.out.print(v+""))
                .count();
        System.out.print(" " + count);
    }
}

What is the result?
A . 6910 3
B . 10126 3
C . 3
D . 6104 3

THE CORRECT ANSWER IS D.

71.
GIVEN:

public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .flatMapToInt(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 != 0))
                .peek(v -> System.out.print(v+""))
                .count();
        System.out.print(" " + count);
    }
}

What is the result?
A . 6910 3
B . 11913 3
C . 3
D . 6104 3

THE CORRECT ANSWER IS B.

71.
GIVEN:
public class Main {
    public static void main(String[] args) {

        int arr[][] ={{5,10},{8,12},{9,3}};
        long count = Stream.of(arr)
                .map(IntStream::of)
                .map(n -> n +1)
                .filter(n -> (n % 2 != 0))
                .peek(v -> System.out.print(v+" "))
                .count();
        System.out.print(" " + count);
    }
}
What is the result?
A . compilation error
B . 11913 3
C . 3
D . 6104 3
THE CORRECT ANSWER IS A. //  .map(n -> n +1) CAN'T add 1 to an object.

72.
GIVEN:
	 Consumer consumer = mess ->  System.out.print; // line 1
         consumer.accept("Hello lamda!");

This code results in a compilaon error.
Which code should be inserted on line 1 for a successful compilaon?
A . Consumer consumer = msg -> { return System.out.print(msg); };
B . Consumer consumer = var arg > {System.out.print(arg);};
C . Consumer consumer = (String args) > System.out.print(args);
D . Consumer consumer = System.out::print;

THE CORRECT ANSWER IS D.

73.
GIVEN:


public class Main {
    public static void main(String[] args) {
        String originalPath = "data\\projects\\a-project\\..\\..\\another-project";
        Path path = Paths.get(originalPath);
        System.out.println(path.normalize());
        System.out.println(path.toAbsolutePath());
    }
}
What is the result?
A . data\another-project
B . data\projects\a-project\another-project
C . data\\projects\\a-project\\..\\..\\another-project
D . data\projects\a-project\..\..\another-project

THE CORRECT ANSWER IS D.

74.
GIVEN:

A company has an exisng sales applicaon using a Java 8 jar file containing packages:
com.company.customer;
com.company.customer.orders;
com.company.customer.info;
com.company.sales;
com.company.sales.leads;
com.company.sales.closed;
com.company.orders;
com.company.orders.pending;
com.company.orders.shipped.
To modularize this jar file into three modules, customer, sales, and orders, which module-info.java
would be correct?

A. 
module com.company.customer {
    exports com.company.customer;
}
module com.company.sales {
    exports com.company.sales;
}
module com.company.orders {
    exports com.company.orders;
}

B.
module com.company.customer {
    opens com.company.customer;
}
module com.company.sales {
    opens com.company.sales;
}
module com.company.orders {
    opens com.company.orders;
}


C.
module com.company.customer {
    reqquires com.company.customer;
}
module com.company.sales {
    reqquires com.company.sales;
}
module com.company.orders {
    reqquires com.company.orders;
}


D.
module com.company.customer {
    provides com.company.customer;
}
module com.company.sales. {
    provides com.company.sales;
}
module com.company.orders {
    provides com.company.orders;
}

THE CORRECT ANSWER IS A

75. 
GIVEN:  

import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class Main {

    public void resourceFindings() {
        List<Reader> dateFiles = new ArrayList<>();
        File indexFile = new File("MyIndex.idx");
        try (BufferedReader indexReader =
                     new BufferedReader(new FileReader(indexFile))) {
            for (String file = indexReader.readLine();
                 file != null; file = indexReader.readLine()) {
                BufferedReader dataReader = new BufferedReader(
                        new FileReader(new File(file)));//line 1
                dateFiles.add(dataReader); // line 2
//                processData(dataReader);//line 3
            }
        } catch (IOException e) {
//..
        } finally {
            for (Reader r : dateFiles) {
                try {
                    r.close();
                } catch (IOException e) {

                }// line 4
            }
        }
    }
}

What will secure this code from a potential Denial of Service condition?
A . Aer Line 4, add indexReader.close().
B . On Line 3, enclose processData(dataReader) with try with resources.
C . After Line 3, add dataReader.close().
D . On Line 1, use try with resources when opening each DataReader.
E . Before Line 1, check the size of dataFiles to make sure it does not exceed a threshold.

CORRECT ANSWER IS D. E will be the next best option followed by C.

76.
GIVEN:

public class Test {
    public static void doThings() throws GeneralException, SpecificException {
        try {
            throw new GeneralException("Something happened");
        } catch (Exception e) {
            throw new SpecificException(e.getMessage());

        }
    }

    public static void main(String[] args) {
        try {
            Test.doThings();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

class GeneralException <LINE 1> {
    public GeneralException(String s) {
        super(s);
    }

}

class SpecificException <LINE 2> {
    public SpecificException(String s) {
        super(s);
    }
}


Which op on should you choose to enable the code to print Something happened?
A . Add extends GeneralExcepti on on line 1. Add extends Excepti on on line 2.
B . Add extends SpecificExcepti on on line 1. Add extends GeneralExcepti on on line 2.
C . Add extends Excepti on line 1. Add extends Excepti on on line 2.
D . Add extends Excepti on on line 1. Add extends GeneralExcepti on on line 2.

CORRECT ANSWER IS C AND D.

77.
GIVEN:

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
            List fruits = Arrays.asList("apple","orange","banana");
            Consumer<String> c =System.out::print;
            Consumer<String> output =  c.andThen(x -> System.out.print(":" + x.toUpperCase()));

            fruits.forEach(output);
    }
}

What is the output?
A . :APPLE:ORANGE:BANANA appleorangebanana
B . :APPLE:ORANGE:BANANA
C . APPLE:apple ORANGE:orange BANANA:banana
D . appleorangebanana :APPLE:ORANGE:BANANA
E . apple:APPLE orange:ORANGE banana:BANANA

CORRECT ANSWER IS D.

78.
Which code is correct?
 A .       Runnable r = "Message" > System.out.println();
 B .      Runnable r = () > System.out::print;
 C .     Runnable r = () -> {System.out.println("Message");};
 D .     Runnable r = >System.out.println("Message");
 E .     Runnable r = {System.out.println("Message")};

CORRECT ANSWER IS C.

79.
GIEVEN:
class X {
}

 final class Y extends X {
    public static void main(String[] args) {
    }
}

What is the result of compiling these two classes?
A . The compila on fails because there is no zero args constructor defined in class X.
B . The compila on fails because either class X or class Y needs to implement the toString() method.
C . The compila on fails because a final class cannot extend another class.
D . The compila on succeeds.

CORRECT ANSWER IS D.

80.
GIVEN:

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) {
        try (BufferedReader in = new BufferedReader(new InputStreamReader(System.in))) {
            System.out.print("Input:");
            String input = in.readLine();
            System.out.println("Echo: " + input);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

And the command:
java Main Helloworld
What is the result ?
A . Input: Echo:
B . Input: Helloworld Echo: Helloworld
C . Input: Then block un l any input comes from System.in.
D . Input: Echo: Helloworld
E . A NullPointerExcep on is thrown at run  me.

CORRECT ANSWER IS B.

81.
Which statement about a func onal interface is true?
A . It must be defined with the public access modifier.
B . It must be annotated with @Func onalInterface.
C . It is declared with a single abstract method.
D . It is declared with a single default method.
E . It cannot have any private methods and sta c methods.

CORRECT ANSWER IS C.

82.
GIVEN: 
class CustomerType<T>{
    public <T> int count (T[] anArray, T element){
        int count = 0;
        for(T e : anArray){
            if(e.equals(element)) ++count;
        }
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
        String[] words = {"banana","orange", "apple", "lemon"};
        Integer[] numbers = {1, 2, 3, 4, 5};
        CustomerType type = new CustomerType();
        CustomerType<String> stringType = new CustomerType<>();
        System.out.println(stringType.count(words, "apple"));
        System.out.println(type.count(words, "apple"));
        System.out.println(type.count(numbers, 3));
    }
}

What is the result?
A . A NullPointerExcep on is thrown at run  me.
B . The compila on fails.
C . 1 Null null
D . 1 1 1
E . A ClassCastExcep on is thrown at run  me.

CORRECT ANSWER IS D.

83.
GIVEN:

public class Tester {
    static class Person implements /*LINE 1 */  {
        private String name;
       public Person(String name) {
            this.name = name;
        }

        /*LINE 2 */
    }

    public static void main(String[] args) {
        Person[] people = {new Person("Joe"),
                new Person("Jane"),
                new Person("John")};

        Arrays.sort(people);
        for (Person person : people) {
            System.out.println(person.name);
        }
    }
}

You want the code to produce this output:
John
Joe
Jane
Which code fragment should be inserted on line 1 and line 2 to produce the output?
A . Insert Comparator<Person> on line 1. Insert public int compare(Person p1, Person p2) { return
p1.name.compare(p2.name); } on line 2.
B . Insert Comparator<Person> on line 1. Insert public int compareTo(Person person) { return
person.name.compareTo(this.name); } on line 2.
C . Insert Comparable<Person> on line 1. Insert public int compare(Person p1, Person p2) { return
p1.name.compare(p2.name); } on line 2.
D . Insert Comparator<Person> on line 1. Insert public int compare(Person person) { return
person.name.compare(this.name); } on line 2.
E . Insert Comparable<Person>  on line 1. Insert public int compareTo(Person o) { return o.name.compareTo(name);} on line 2.

CORRECT ANSWER IS E.

84.
GIVEN: 
public class Main {
    public static void main(String[] args) {
        try {
            Path path = Paths.get("/uo1/work/filestore.txt");
            boolean result = Files.deleteIfExists(path);
            if (result) {
                System.out.println(path + " is Deleted ");
            } else {
                System.out.println(path + " is not Deleted ");
            }
        } catch (IOException e) {
            System.out.println("Exception");
        }
    }
}

Assume the file on path does not exist. What is the result?
A . The compila on fails.
B . /u01/work/filestore.txt is not deleted.
C . Excep on
D . /u01/work/filestore.txt is deleted.

CORRECT ANSWER IS B.

85.
GIVEN:

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface AuthorInfo {
    String author() default "";

    String date();

    String[] comments() default {};
}

WHAT OPTION IS CORRECT?
A. 
@AuthorInfo(date = "2020-1-1", comments = {})
class  Hello{
    public void func(){
    }
}


B. 
class  Helloo{
    @AuthorInfo(date = "2020-1-1", comments = "")
    public void func(){
    }
}

C.
class  Hellooo{
    @AuthorInfo()
    public void func(){
    }
}

D.
@AuthorInfo(date = "2020-1-1", comments = "")
class  Hellooo{
    public void func(){
    }
}

CORRECT ANSWER IS B.

86.
GIVEN:

public class MyResource  {
    public MyResource(){
    }
//RESOURCE METHOD.
}

You want to use the myResource class in a try-with-resources statement. Which change will accomplish
this?
A . Extend AutoCloseable and override the close method.
B . Implement AutoCloseable and override the autoClose method.
C . Extend AutoCloseable and override the autoClose method.
D . Implement AutoCloseable and override the close method.

CORRECT ANSWER IS D.

87.
Which interface in the java.u l.func on package will return a void return type?
A . Supplier
B . Predicate
C . Func on
D . Consumer

CORRECT ANSWER IS D.

88.
GIVEN:

public class Main {
    public static void main(String... args) {

        List<Employee> list = List.of(new Employee("John", 80000.0),new Employee("Scott", 90000.0));
        double starts =0.0;
        double ratio = 1.0;
        BinaryOperator<Double> bo = (a, b) -> a+b;
        double totalSalary = list.stream().map(e -> e.getSalary() * ratio).reduce(starts,bo); // LINE 1
        System.out.println("Total salary =" + totalSalary);
    }
}

class Employee{
    String name;
    double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}

Which statement is equivalent to line 1?
A . double totalSalary = list.stream().map(e > e.getSalary() * ra o).reduce (bo).ifPresent (p >
p.doubleValue());
B . double totalSalary = list.stream().mapToDouble(e -> e.getSalary() * ratio).sum();
C . double totalSalary = list.stream().map(Employee::getSalary * ra o).reduce (bo).orElse(0.0);
D . double totalSalary = list.stream().mapToDouble(e > e.getSalary() * ra o).reduce(starts, bo);

CORRECT ANSWER IS B.
OTHER POSSIBLE ANSWERS WITH CHANGES ARE
A. double totalSalary1 = list.stream().map(Employee::getSalary).reduce (bo).orElse(0.0);
B. DoubleBinaryOperator bo1 = (a, b) -> a + b; 
	double totalSalary = list.stream().mapToDouble(e -> e.getSalary() * ratio).reduce(starts,bo1);

89.
GIVEN:

public class Employee {

    private String name;
    private LocalDate birthday;

  //GETTER
//SETTER
//CONSTRUCTORS

    public static void main(String[] args) {
        List<Employee> roster = new ArrayList<>();
        roster.add(new Employee("Sam", LocalDate.now()));
        roster.add(new Employee("Tabi", LocalDate.of(1970,10,10)));

        Predicate<Employee> y = (Employee e) -> e.getBirthday().isBefore(IsoChronology.INSTANCE.date(1989,1,1));
        Set<String> s1 = roster.stream()
                .collect(Collectors.partitioningBy(y))
                .get(true)
                .stream().map(Employee::getName)
                .collect(Collectors.toSet());
        System.out.println(s1);

    }
}
Which code fragment on line 1 makes the s1 set contain the names of all employees born before
January 1, 1989?

A.
.collect(Collectors.partitioningBy(y))
                .get(true)
                .stream().map(Employee::getName)
                .collect(Collectors.toSet());
B.
.collect(Collectors.partitioningBy(y,
                        Collectors.mapping(Employee::getName,Collectors.toSet())));
C. .collect(Collectors.partitioningBy(y,
                        Collectors.mapping(Employee::getName, Collectors.toCollection(TreeSet::new))))
D.
.collect(Collectors.partitioningBy(y))
                .get(true)
                .map(Employee::getName)
                .collect(Collectors.toCollection(TreeSet::new));

CORRECT ANSWER IS A.
// B AND C returns a Map<Boolean, Set<String>>  and D does not compile.

90.
GIVEN: 
public static void main(String[] args) {
        try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in));){
            String input  = br.readLine();
            System.out.println("Input String was: " + input);
        }catch(IOException e){
            e.getStackTrace();
        }
    }
Which is true?
A . System.out is the standard output stream. The stream is open only when System.out is called.
B . System.in cannot reassign the other stream.
C . System.out is an instance of java.io.OutputStream by default.
D . System.in is the standard input stream. The stream is already open.

CORRECT ANSWER IS D.

91.
GIVEN:

public class Main {
    public static void main(String[] args) {
        try {
      
            //LINE 1
            lines.map(l -> l.toUpperCase())
                    .forEach((line) -> {
                        try {
                            Files.write(Paths.get("outputfile_to_path"),
                                    line.getBytes(), StandardOpenOption.CREATE);
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

You want to obtain the Stream object on reading the file. Which code inserted on line 1 will accomplish
this?
A . var lines = Files.lines(Paths.get(INPUT_FILE_NAME));
B . Stream lines = Files.readAllLines(Paths.get(INPUT_FILE_NAME));
C . var lines = Files.readAllLines(Paths.get(INPUT_FILE_NAME));
D . Stream<String> lines = Files.lines(INPUT_FILE_NAME);

CORRECT ANSWER IS A.

92.
GIVEN:

   public static void main(String[] args) {

    //LINE 1
        List<String> fruits = new ArrayList<>(List.of("apple","orange","banana"));
        fruits.replaceAll(function);
        System.out.println(fruits);
    }

Which statement on line 1 enables this code fragment to compile?
A . Func tion func on = String::toUpperCase;
B . UnaryOperator func on = s > s.toUpperCase();
C . UnaryOperator<String> func on = String::toUpperCase;
D . Func on<String> func on = m > m.toUpperCase();

CORRECT ANSWER IS C.

93.
GIVEN: 

var numbers = List.of(0,1,2,3,4,5,6,7,8,9);
You want to calculate the average of numbers. Which two codes will accomplish this? (Choose two.)
A . double avg = numbers.stream().parallel().averagingDouble(a > a);
B . double avg = numbers.parallelStream().mapToInt (m > m).average().getAsDouble ();
C . double avg = numbers.stream().mapToInt (i > i).average().parallel();
D . double avg = numbers.stream().average().getAsDouble();
E . double avg = numbers.stream().collect(Collectors.averagingDouble(n > n));

CORRECT ANSWER IS B AND E.

94.
GIVEN:

public enum Color implements Serializable {
    R(1), G(2), B(3);
    int c;

    public Color(int c) {
        this.c = c;
    }
}

What acon ensures successful compilation?
A . Replace public Color(int c) with private Color(int c).
B . Replace int c; with private int c;.
C . Replace int c; with private final int c;.
D . Replace enum Color implements Serializable with public enum Color.
E . Replace enum Color with public enum Color.

CORRECT ANSWER IS A.

95.
GIVEN:

module main{
    exports country;
    uses country.countryDdetails;
 }

Which two are true? (Choose two.)
A . A module providing an implementaon of country.CountryDetails can be compiled and added
without recompiling the main module.
B . A module providing an implementaon of country.CountryDetails must have a requires main;
direcve in its module-info.java file.
C . An implementaon of country.countryDetails can be added to the main module.
D . To compile without an error, the applicaon must have at least one module in the module source
path that provides an implementaon of country.CountryDetails.
E . To run without an error, the applicaon must have at least one module in the module path that
provides an implementaon of country.CountryDetails.

CORRECT ANSWER IS A AND D.

96.
Which code fragment prints 100 random numbers?

A.
   var r = new Random();
        DoubleStream.generate(r::nextDouble)
                .limit(100)
                .forEach(System.out::println);
B.
        DoubleStream.generate(Random::nextDouble)
                .limit(100)
                .forEach(System.out::println);
C.
 var r = new Random();
        new DoubleStream(r::nextDouble)
                .limit(100)
                .forEach(System.out::println);
D.
 DoubleStream.generate(Random.nextDouble)
                .limit(100)
                .forEach(System.out::println);
CORRECT ANSWER IS A. 

97.
GIVEN:

public class Hello {
    class Greeting {
        void sayHi() {
            System.out.println("Hello World");
        }
    }

    public static void main(String[] args) {
        //LINE 1
    }
}

What code must you insert on Line 1 to enable the code to print Hello World?
A . Hello.Greeng myG = new Hello.Greeng();
    myG.sayHi();
B . Hello myH = new Hello();
    Hello.Greeng myG = myH.new Greeng();
    myG.sayHi();
C . Hello myH = new Hello();
    Hello.Greeng myG = myH.new Hello.Greeng();
    myG.sayHi();
D . Hello myH = new Hello(); 
    Greeng myG = new Greeng();
    myG.sayHi ();

CORRECT ANSWER IS B. 

98.
Which two are successful examples of autoboxing? (Choose two.)
A . String a = "A";
B . Integer e = 5;
C . Float g = Float.valueOf(null);
D . Double d = 4;
E . Long c = 23L;
F . Float f = 6.0;

CORRECT ANSWER IS B AND E. 

99.
Which code fragment compiles?

A.
   Comparator comparator4 = new Comparator<?>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        };
B.
 Comparator<> comparator2 = new Comparator<Integer>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        };
C.
 Comparator<Integer> comparator3 = new Comparator<>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        };

D.
 var comparator6 = new Comparator<>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        };
CORRECT ANSWER IS C.

100.
Given:

    public static void main(String[] args) {
        var data = new ArrayList<>();
        data.add("Peter");
        data.add(30);
        data.add(40);
        data.add("Market Road");
        data.set(1, 25);
        data.remove(2);
        data.set(2, 1000L);
        System.out.print(data);
    }

What is the output?
A . [Market Road, 1000]
B . [Peter, 30, Market Road]
C . [Peter, 25, 1000]
D . An excepti on is thrown at runtime.

CORRECT ANSWER IS C.

101.
GIVEN:
var fruits = List.of(''apple'', ''orange'', ''banana'', ''lemon'');
You want to examine the first element that contains the character n. Which statement will accomplish
this?
A . String result = fruits.stream().filter(f > f.contains(''n'')).findAny();
B . fruits.stream().filter(f > f.contains(''n'')).forEachOrdered(System.out::print);
C . Op onal<String> result = fruits.stream().filter(f > f.contains ("n")).findFirst();
D . Op onal<String> result = fruits.stream().anyMatch(f > f.contains(''n''));

CORRECT ANSWER IS C.

102.
GIVEN:

public class Main {
    public static void main(String[] args) {
        var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Function<Integer, Integer> f = n -> n * 2;
        StringBuilder sb = new StringBuilder();
        for (int a : numbers) {
            sb.append(f.apply(a));
            sb.append(" ");
        }
        System.out.println(sb.toString());
    }
}

Which statement on line 1 enables this code to compile?
A . Func on<Integer, Integer> f = n > n * 2;
B . Func on<Integer> f = n > n * 2;
C . Func on<int> f = n > n * 2;
D . Func on<int, int> f = n > n * 2;
E . Func on f = n > n * 2;

CORRECT ANSWER IS A.

103.
Assuming the Widget class has a getPrice method, this code does not compile:

    public static void main(String[] args) {
        List<Widget> widgets =
                List.of(new Widget("Basic Widget", 19.55),// LINE 1
                new Widget("Enhanced Widget", 35.55),
                new Widget("Luxury Edition Widget", 55.55));
        Stream  widgetStream = widgets.stream(); // LINE 2
        widgetStream.filter((Widget a) -> a.getPrice() > 20.00) // LINE 3
.forEach(System.out::println);
    }

Which two statements, independently, would allow this code to compile? (Choose two.)
A . Replace line 3 with widgetStream.filter(a > ((Widget)a).getPrice() > 20.00).
B . Replace line 1 with List<Widget> widgetStream = widgets.stream();.
C . Replace line 3 with widgetStream.filter((Widget a) > a.getPrice() > 20.00).
D . Replace line 2 with Stream<Widget> widgetStream = widgets.stream();

CORRECT ANSWER IS  C, D.

104.
Which two are successful examples of autoboxing? (Choose two.)
A . String a = ''A'';
B . Integer e = 5;
C . Float g = Float.valueOf(null);
D . Double d = 4;
E . Long c = 23L;
F . Float f = 6.0;

CORRECT ANSWER IS B AND E.
//Autoboxing is the automatic conversion of a primitive data type into its corresponding wrapper class object.

105.
Which code fragment compiles?

A.  Comparator<Integer> comparator1 = new Comparator<>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return 0;
            }
        };

 B.       Comparator<> comparator2 = new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return 0;
            }
        };
 C.      var comparator3 = new Comparator<>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return 0;
            }
        };
D.        Comparator comparator4 = new Comparator<?>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return 0;
            }
        };

CORRECT ANSWER IS A.

106.
GIVEN:
Assume ds is a DataSource and the EMP table is defined appropriately.

    public static void main(String[] args) {
        try (Connection conn = DriverManager
                .getConnection("jdbc:mysql://localhost:3306/BANK_DB", "root", "password");
             PreparedStatement ps = conn.prepareStatement("INSERT INTO EMP VALUES(?,?,?)")) {
            ps.setObject(1, 103, JDBCType.INTEGER);
            ps.setObject(2, "SMITH", JDBCType.VARCHAR);
            ps.setObject(3, "HR", JDBCType.VARCHAR);
            ps.executeUpdate();
            ps.setInt(1, 102);
            ps.setString(2, "JONES");
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

What does executing this code fragment do?
A . inserts two rows (101, 'SMITH', 'HR') and (102, 'JONES', NULL)
B . inserts two rows (101, 'SMITH', 'HR') and (102, 'JONES', 'HR')
C . inserts one row (101, 'SMITH', 'HR')
D . throws a SQLExcep on

CORRECT ANSWER IS B.

107.
GIVEN:
Assume ds is a DataSource and the EMP table is defined appropriately.

    public static void main(String[] args) {
        try (Connection conn = DriverManager
                .getConnection("jdbc:mysql://localhost:3306/BANK_DB", "root", "pvi@2019");
             PreparedStatement ps = conn.prepareStatement("INSERT INTO EMP VALUES(?,?,?)")) {
            ps.setInt(1, 102);
            ps.setString(2, "JONES");
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

What does executing  this code fragment do?
A . inserts two rows (101, 'SMITH', 'HR') and (102, 'JONES', NULL)
B . inserts two rows (101, 'SMITH', 'HR') and (102, 'JONES', 'HR')
C . inserts one row (101, 'SMITH', 'HR')
D . throws a SQLExcep on

CORRECT ANSWER IS D.

108.
GIVEN:

public class Main {
   private static class Greet {
        private void print() {
            System.out.println("Hello world");
        }
    }

    public static void main(String[] args) {
        Main.Greet i = new Greet();
        i.print();
    }
}

What is the result?
A . The compila on fails at line 9.
B . The compila on fails at line 2.
C . Hello World
D . The compila on fails at line 8.

CORRECT ANSWER IS C.

109.
GIVEN:

public class Main {

    public static void main(String[] args) {
        Optional<String> value = createValue();
        String str = value.orElse("Duke");
        System.out.println(str);
    }

    private static Optional<String> createValue() {
        String s = null;
        //System.out.println(s);
        return Optional.ofNullable(s);
    }
}

What is the output?
A . null
B . A NoSuchElementExcep on is thrown at run Time.
C . Duke
D . A NullPointerExcep on is thrown at runTi me.

CORRECT ANSWER IS C.

110.
Which code fragment does a service use to load the service provider with a Print interface?
A . private Print print = com.service.Provider.getInstance();
B . private java.uti l.ServiceLoader<Print> loader = ServiceLoader.load (Print.class);
C . private java.uti l.ServiceLoader<Print> loader = new java.uti l.ServiceLoader<> ();
D . private Print print = new com.service.Provider.PrintImpl();

CORRECT ANSWER IS B.

110.
GIVEN:

public class Main {

    public static void main(String[] args) {
        Thread t1 = new Thread(new MyThread());
        Thread t2 = new Thread(new MyThread());
        Thread t3 = new Thread(new MyThread());

        t1.start();
        t2.run();
        t3.start();
        t2.start();
        t1.start();
    }
}

class MyThread implements Runnable {
    public void run() {
        System.out.println("Running. " + Thread.currentThread().getName());
    }
}

Which one is correct?
A . An IllegalThreadStateExcep on is thrown at run  me.
B . Three threads are created.
C . The compila on fails.
D . Four threads are created.

CORRECT ANSWER IS A.

111.
GIVEN:
interface TestInterface {
    default void samplingProbeProcedure() {
        probeProcedure();
        System.out.println("Collect Sample");
        System.out.println("Leave Asteriod");
        System.out.println("Dock with main Craft");
    }

    default void explosionProbeProcedure() {
        probeProcedure();
        System.out.println("Explode");
    }
}

Eliminate code duplica on.
Keep constant the number of methods other classes may implement from this interface.
Which method can be added to meet these requirements?

A.      private void probeProcedure() {
        System.out.println("Luanch Probe");
        System.out.println("Land as Asteroid");
    }

B.      private default void probeProcedure() {
        System.out.println("Luanch Probe");
        System.out.println("Land as Asteroid");
    }

C.      private static void probeProcedure() {
        System.out.println("Luanch Probe");
        System.out.println("Land as Asteroid");
    }

D.      default void probeProcedure() {
        System.out.println("Luanch Probe");
        System.out.println("Land as Asteroid");
    }

CORRECT ANSWER IS A.

112.
Given these two classes:

class Resource {
    public Worker owner;

    public synchronized boolean claim(Worker worker) {
        if (owner == null) {
            owner = worker;
            return true;
        } else {
            return false;
        }
    }

    public synchronized void release() {
        owner = null;
    }
}

public class Worker {
    public synchronized void work(Resource... resources) {
        for (int i = 0; i < 10; i++) {
            System.out.println(i);
            while (!resources[0].claim(this)) {
                System.out.println("resources[0]: " + i);
            }

            while (!resources[1].claim(this)) {
                System.out.println("resources[1]: " + i);
            }
            resources[1].release();
            resources[0].release();
        }
    }
}

class Main {
    public static void main(String[] args) {
        Worker worker1 = new Worker();
        Worker worker2 = new Worker();
        Resource resource1 = new Resource();
        Resource resource2 = new Resource();

        new Thread(() -> {
            worker1.work(resource1, resource2);
        }).start();

        new Thread(() -> {
            worker2.work(resource1, resource2);
        }).start();
    }
}
Which describes the fragment?
A . It throws IllegalMonitorStateExcepon.
B . It is subject to deadlock.
C . It is subject to livelock.
D . The code does not compile.

CORRECT ANSWER IS B.

113.
GIVEN:
enum Alphabet {
    A, B, C;
//line 1
}
Examine this code:
System.out.println(Alphabet.getFirstLe er());
What code should be wri en at line 3 to make this code print A?
A . final String getFirstLe er() { return A.toString(); }
B . sta c String getFirstLe er() { return Alphabet.values()[1].toString(); }
C . sta c String getFirstLe er() { return A.toString(); }
D . String getFirstLe er() { return A.toString(); }

CORRECT ANSWER IS C.

114.
consideration is based on java 11
Which interfaces can be used in lambda expressions? 

A. interface MyInterface1 {
    int method();

    private void pMethod() {
    }
}

B. interface MyInterface2 {
    static void sMethod() {

    }

    boolean equals();

}

C. interface MyInterface3 {
    void method();

    void method(String method);
}

D. interface MyInterface4 {
    static void dMethod() {

    }

    void method();
}

E. interface MyInterface5 {
    static void sMethod();
    void method(String method);
}

Which interfaces can be used in lambda expressions? 
A . MyInterface1
B . MyInterface3
C . MyInterface5
D . MyInterface2
E . MyInterface4

CORRECT ANSWER IS A, B, D

115. 
GIVEN:

 @interface Resource {
    String name();
    int priority() default 0;
}

//LINE 1
public class Student {
}


Which two annotations may be applied at LINE 1 in the code fragment? (Choose two.)
A . @Resource(priority=100)
B . @Resource(priority=0)
C . @Resource(name="Customer1")
D . @Resource(name="Customer1", priority=100)
E . @Resource

CORRECT ANSWER IS C,D.

116.
Given the code fragment:
Path currentFile = Paths.get(''/scratch/exam/temp.txt'');
Path outputFile = Paths get(''/scratch/exam/new.txt'');
Path directory = Paths.get(''/scratch/'');
Files.copy(currentFile, outputFile);
Files.copy(outputFile, directory);
Files.delete (outputFile);
The /scratch/exam/temp.txt file exists. The /scratch/exam/new.txt and /scratch/new.txt files do not
exist.
What is the result?
A . /scratch/exam/new.txt and /scratch/new.txt are deleted.
B . The program throws a FileaAlreadyExistsExcep on.
C . The program throws a NoSuchFileExcep on.
D . A copy of /scratch/exam/new.txt exists in the /scratch directory and /scratch/exam/new.txt is
deleted.

CORRECT ANSWER IS D.

117.
What makes Java dynamic?
A . At run me, classes are loaded as needed, and new code modules can be loaded on demand.
Answer: C, E
Ques on: 120
Answer: C
Ques on: 121
B . The run me can process machine language sources as well as executables from diﬀerent language
compilers.
C . The Java compiler uses reflection to test if class methods are supported by resources of a target
platf orm.
D . The Java compiler preprocesses classes to run on specific target plat forms.

CORRECT ANSWER IS A.

118.
GIVEN:

public class Main {
    public static void main(String[] args) {
        for (var i = 0; i < 10; i++) {
            switch (i % 5) {
                case 2:
                    i *= i; // 4
                    break;
                case 3:
                    i++;
                    break;
                case 1:
                case 4:
                    i++;
                    continue;
                default:
            }

            System.out.print(i + " ");
            i++; 
        }
    }
}

What is the result?
A . nothing
B . 0
C . 10
D . 0 4 9

CORRECT ANSWER IS D.

119.
GIVEN:

public class Main {

    public static void greet(String... args) {
        System.out.println("Hello");
        for (String arg : args) {
            System.out.println(arg);
        }
    }

    public static void main(String[] args) {
        Main c = null;
        c.greet();
    }
}

What is the result?
A . NullPointerExcep on is thrown at line 4.
B . NullPointerExcep on is thrown at line 10.
C . A compilati on error occurs.
D . Hello

CORRECT ANSWER IS D.

120.
GIVEN:

public class Main {

    public  void greet(String... args) {
        System.out.println("Hello");
        for (String arg : args) {
            System.out.println(arg);
        }
    }

    public static void main(String[] args) {
        Main c = null;
        c.greet(); // line
    }
}

What is the result?
A . NullPointerExcep on is thrown.
B . Hello and NullPointerExcep on is thrown.
C . A compilati on error occurs.
D . Hello

CORRECT ANSWER IS A.


121.

GIVEN:
class Super {
    static String greeting() {
        return "Good Night";
    }

    String name() {
        return "Harry";
    }
}

class Sub extends Super {
    static String greeting() {
        return "Good Morning";
    }

    String name() {
        return "Potter";
    }
}


class Test {
    public static void main(String[] args) {
        Super s = new Super();
        System.out.println(s.greeting() + ", " + s.name());
    }
}

What is the result?
A . Good Morning, Pott er
B . Good Night, Po tter
C . Good Morning, Harry
D . Good Night, Harry

CORRECT ANSWER IS C. 
Note We can not override static method, so the method belong to the class. Polymorphysm

122.

GIVEN:
class Super {
    static String greeting() {
        return "Good Night";
    }

    String name() {
        return "Harry";
    }
}

class Sub extends Super {
    static String greeting() {
        return "Good Morning";
    }

    String name() {
        return "Potter";
    }
}


class Test {
    public static void main(String[] args) {
        Super s = new Super();
        System.out.println(s.greeting() + ", " + s.name());
    }
}

What is the result?
A . Good Morning, Pott er
B . Good Night, Po tter
C . Good Morning, Harry
D . Good Night, Harry

CORRECT ANSWER IS B. 
Note We can not override static method, so the method belong to the class. Polymorphysm

123.
GIVEN:

public class Person {

    private String name;

    public Person(String name) {
        this.name = name;

    }

    @Override
    public String toString() {
        return name;
    }
}

class Tester {
    public static void main(String[] args) {
        Person p = null;
        checkPerson(p);
        System.out.println(p);
        p = new Person("Mary");
        checkPerson(p);
        System.out.println(p);

    }

    public static Person checkPerson(Person p) {

        if (p == null) {
            p = new Person("Joe");

        } else {
            p = null;
        }
        return p;
    }
}

What is the result?
A . JoeMarry
B . Joenull
C . nullnull
D . nullMary

CORRECT ANSWER IS D. 

124.
GIVEN:

public class Person {

    private String name;

    public Person(String name) {
        this.name = name;

    }

    @Override
    public String toString() {
        return name;
    }
}

class Tester {
    public static void main(String[] args) {
        Person p = null;
       p = checkPerson(p);
        System.out.println(p);
        p = new Person("Mary");
        checkPerson(p);
        System.out.println(p);

    }

    public static Person checkPerson(Person p) {

        if (p == null) {
            p = new Person("Joe");

        } else {
            p = null;
        }
        return p;
    }
}

What is the result?
A . JoeMarry
B . Joenull
C . nullnull
D . nullMary

CORRECT ANSWER IS A. 


125.

   module java.se{
        requires transitive java.sql;
        }
        What does the transi ve modifier mean?
A . Only a module that requires the java.se module is permi ed to require the java.sql module.
B . Any module that requires the java.se module does not need to require the java.sql module.
C . Any module that a empts to require the java.se module actually requires the java.sql module
instead.
D . Any module that requires the java.sql module does not need to require the java.se module.

CORRECT ANSWER IS B.

126.
GIVEN:

abstract class Automobile {
    abstract void wheels();
}

class Car extends Automobile {
    void wheels(int a) { //line 1
        System.out.println(4); //line 2
    }

    public static void main(String[] args) {
        Automobile ob = new Car(); //line 3
        ob.wheels(); //line 4
    }
}
What must you do so that the code prints 4?
A . Remove the parameter from wheels method in line 1.
B . Add @Override annotati on in line 2.
C . Replace the code in line 2 with Car ob = new Car();
D . Remove abstract keyword in line 1.

CORRECT ANSWER IS A.


127.
GIVEN:

class Foo {
    public void foo(Collection collection) {
        System.out.println("Bonjour le monde!");
    }
}

class Bar extends Foo {
    
    public void foo(Collection collection) {
        System.out.println("Hello world!");
    }

    public void foo(List arg) {
        System.out.println("Hola Mundo!");
    }

    public static void main(String[] args) {

        Foo f1 = new Foo();
        Foo f2 = new Bar();
        Bar b1 = new Bar();
        List<String> li = new ArrayList<>();

        b1.foo(li);
        f1.foo(li);
        f2.foo(li);
    }
}


Which three are correct? (Choose three.)
A . b1.foo(li) prints Hello world!
B . f1.foo(li) prints Bonjour le monde!
C . f1.foo(li) prints Hello world!
D . f1.foo(li) prints Hola Mundo!
E . b1.foo(li) prints Bonjour le monde!
F . f2.foo(li) prints Hola Mundo!
G . f2.foo(li) prints Bonjour le monde!
H . b1.foo(li) prints Hola Mundo!
I . f2.foo(li) prints Hello world!

CORRECT ANSWER IS H,B,I. 
ALWAYS TAKE NOTE OF THE OBJECTS BEEN CREATED AND IF POLYMORPHYS ARE BEING USED.

128.
GIVEN:

class Fox implements Forest, Town {


    public static void main(String[] args) {
        Fox fo = new Fox();
        fo.inhabit();
    }

    
}

interface Habtat {

    abstract void inhabit();
}

interface Town extends Habtat {

    default void inhabit() {
        System.out.println("Town");
    }
}

interface Forest extends Habtat {

    default void inhabit() {
        System.out.println("Forest");
    }
}


Which statement is true about the Fox class?
A . Fox class does not have to override inhibit method, so long as it does not try to call it.
B . Fox class does not have to override the inhabit method if Forest and Town provide compa ti ble implementations.
C . Fox class must implement either Forest or Town interfaces, but not both.
D . The inhabit method implementation from the first interface that Fox implements will take
precedence.
E . Fox class must provide an implementation for the inhabit method.

CORRECT ANSWER IS D.

129.
public class Main {

    public static void checkConfiguration(String fileName) {

        File file = new File(fileName);
        if (!file.exists()) {
            throw new Error("Configuration file Error. " + fileName + " is missing");
        }
    }

    public static void main(String[] args) {
        checkConfiguration("HELLO.txt");
        System.out.println("Configuration Okay");
    }
}

If file 'HELLO.txt' is not found, what is the result?
A . Configuration Okay
B . The compilati on fails
C . Excep tion in thread 'main' java.lang.Error:Fatal Error: Configura on File, HELLO.txt, is missing.
D . nothing

CORRECT ANSWER IS A.

130.
Given:

class DNASynth {
    int aCount;
    int tCount;
    int cCount;
    int gCount;

    int getACount(int aCount) {
        return aCount;
    }

    int getTCount(int tCount) {
        return this.tCount;
    }

    int getCCount() {
        return getTotalCount() - this.aCount - getTCount(0) - gCount;
    }

    int getGCount() {
        return getGCount();
    }

    int getTotalCount() {
        return aCount + getTCount(0) + this.cCount + this.gCount;
    }
}
Which two methods facilitate valid ways to read instance fields? (Choose two.)
A . getTCount
B . getACount
C . getTotalCount
D . getCCount
E . getGCount

CORRECT ANSWER IS A,C,D.

131
GIVEN:

class Person {

    private String name = "Joe Bloggs";

    public Person(String name) {
        this.name = name;
    }

    public String toString() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person(); //line 1
        System.out.println(p1);
    }
}

What is the result?
A . null
B . Joe Bloggs
C . The compila tion fails due to an error in line 1.
D . p1

CORRECT ANSWER IS C.

132
GIVEN:

class Person {

    private String name = "Joe Bloggs";

    public Person() {
    }

    public String toString() {
        return name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person p1 = new Person(); //line 1
        System.out.println(p1);
    }
}

What is the result?
A . null
B . Joe Bloggs
C . The compila tion fails due to an error in line 1.
D . p1

CORRECT ANSWER IS B.

133.
GIVEN:

class Foo {

    public void foo(Collection arg) {
        System.out.println("Bonjour le monde!");
    }
}

class Bar extends Foo {
    public void foo(Collection arg) {
        System.out.println("Hello world!");
    }

    public void foo(List arg) {
        System.out.println("Hola Mundo!");
    }

    public static void main(String[] args) {

        Foo f1 = new Foo();
        Foo f2 = new Bar();
        Bar b1 = new Bar();
        Collection<String> c = new ArrayList<>();
        b1.foo(c); // D
        f2.foo(c); // H
        f1.foo(c); // I
    }
}
Which three are true? (Choose three.)

A . b1.foo(c) prints Bonjour le monde!
B . f1.foo(c) prints Hello world!
C . f1.foo(c) prints Ol Mundo!
D . b1.foo(c) prints Hello world!
E . f2.foo(c) prints Ol Mundo!
F . b1.foo(c) prints Ol Mundo!
G . f2.foo(c) prints Bonjour le monde!
H . f2.foo(c) prints Hello world!
I . f1.foo(c) prints Bonjour le monde!

CORRECT ANSWER IS D,H,I.

134.
GIVEN:

public class Main {
    public static void main(String[] args) {
        Integer s = 0;
        if (Double.parseDouble("11.00f") > 11) {
            s += 1;
        }

        if (1_7 == Integer.valueOf("17")) {
            s += 2;
        }

        if (1024 > 1023L) {
            s += 3;
        }
        System.out.println(s);
    }
}

What is the result?
A . 23
B . 12
C . 123
D . 13
E . 5
CORRECT ANSWER IS E.

135.
GIVEN:

public class Main {
    public static void main(String[] args) {
        String s = "";
        if (Double.parseDouble("11.00f") > 11) {
            s += 1;
        }

        if (1_7 == Integer.valueOf("17")) {
            s += 2;
        }

        if (1024 > 1023L) {
            s += 3;
        }
        System.out.println(s);
    }
}

What is the result?
A . 23
B . 12
C . 123
D . 13
E . 5
CORRECT ANSWER IS A.

135.
GIVEN:

public class Main {
    public static void main(String[] args) {
        Integer s = null;
        if (Double.parseDouble("11.00f") > 11) {
            s += 1;
        }

        if (1_7 == Integer.valueOf("17")) {
            s += 2;
        }

        if (1024 > 1023L) {
            s += 3;
        }
        System.out.println(s);
    }
}

What is the result?
A . 23
B . 12
C . 123
D . 13
E . 5
F . Runtime exception
CORRECT ANSWER IS F.

136.
GIVEN:

public class Main {
    public static void main(String[] args) {
        String s = null;
        if (Double.parseDouble("11.00f") > 11) {
            s += 1;
        }

        if (1_7 == Integer.valueOf("17")) {
            s += 2;
        }

        if (1024 > 1023L) {
            s += 3;
        }
        System.out.println(s);
    }
}

What is the result?
A . null23
B . 23
C . 123
D . 13
E . 5
F . Runtime exception
CORRECT ANSWER IS A.

137.
GIVEN:
public class Main {
    public static void main(String[] args) {
        try {
            doA();
        }// Line 1
    }

    private static void doA() throws FileNotFoundException, IndexOutOfBoundsException {
        if (false) {
            throw new FileNotFoundException();

        } else {
            throw new IndexOutOfBoundsException();
        }
    }
}
What must be added in line 1 to compile this class?
A . catch(IOExcep on e) { }
B . catch(FileNotFoundExcep on | IndexOutOfBoundsExcep on e) { }
C . catch(FileNotFoundExcep on | IOExcep on e) { }
D . catch(IndexOutOfBoundsExcep on e) { }catch(FileNotFoundExcep on e) { }
E . catch(FileNotFoundExcep on e) { }catch(IndexOutOfBoundsExcep on e) { }

CORRECT ANSWER IS A.

138.
executed with this command:
java Main 2 2 2

    public static void main(String[] args) {
        int i = 1;
        for (String s : args) {
            int value  = Integer.parseInt(s);
            System.out.println(" " + s + " " + (value + i));
        }
    }
What is the output of this class?
A . The compila on fails.
B . 2 3  2 3  2 3 
C . A java.lang.ArrayIndexOutOfBoundsExcep on is thrown.
D . 1) one
E . nothing

CORRECT ANSWER IS B.

139.
GIVEN:
   public static void main(String[] args) {
        byte x = 7, y = 6;
        float z = Math.round((float) x / y * 100) / (float) 100;
        System.out.println(z);
    }

Which expression when added at line 1 will produce the output of 1.17?
A . float z = (float)(Math.round((float)x/y*100)/100);
B . float z = Math.round((int)(x/y),2);
C . float z = Math.round((float)x/y,2);
D . float z = Math.round((float)x/y*100)/(float)100;

CORRECT ANSWER IS D.

140.
GIVEN:

    public static void main(String[] args) {
        int x = 4;
        int y = 2;
        System.out.println(x + y + "(x+y)" + x + y);
    }

What is the result?
A . An excep tion is thrown at run time.
B . 42(x+y)42
C . 42(x+y)6
D . 6(x+y)42
E . 6(x+y)6

CORRECT ANSWER IS D.

141.
GIVEN:

      public static void main(String[] args) {
        int x = 4;
        int y = 2;
        System.out.println(x + y + "" + (x + y) + "" + x + y);
    }


What is the result?
A . An excep tion is thrown at run time.
B . 42642
C . 4266
D . 6642
E . 666

CORRECT ANSWER IS D.

142.
GIVEN:

public abstract class Animal {
    protected abstract void walk();
}

public  abstract class Human extends Animal {

//LINE 1
}

Which two lines inserted in line 1 will allow this code to compile? (Choose two.)
A . protected void walk(){}
B . void walk(){}
C . abstract void walk();
D . private void walk(){}
E . public abstract void walk();

CORRECT ANSWER IS A AND E.

143.
GIVEN:

public class X {

    private Collection collection;

    public void set(Collection collection) {
        this.collection = collection;
    }

    public Collection getCollection() {
        return collection;
    }
}

class Y extends X {

    public void set(Map<String, String> map) {
        super.set(map);
    }

    public static void main(String[] args) {
        Y y = new Y();
        Map<String, String> map = new HashMap<String, String>();
        map.put("1", "One");
        map.put("2", "Two");
        map.put("3", "Three");
        y.set(map);
        y.getCollection().forEach(System.out::println);
    }
}

Which two lines can replace line 1 so that the Y class compiles? (Choose two.)
A . map.forEach((k, v) -> set(v)));
B . set(map.values());
C . super.set(List<String> map)
D . super.set(map.values());
E . set(map)

CORRECT ANSWER IS B AND D.

144.
GIVEN:
class Main {
    private int sum;

    public int compute() {
        int x = 0;
        while (x < 3) {
            sum += x++;
        }
        return sum; // 6
    }

    public static void main(String[] args) {
        Main t = new Main();
        int sum = t.compute();
        sum = t.compute();
        t.compute();
        System.out.println(sum);

    }
}

What is the result?
A . 9
B . An excep on is thrown at run me.
C . 3
D . 6

CORRECT ANSWER IS D.

145.
GIVEN:

class Main {
    private int sum;

    public int compute() {
        int x = 0;
        while (x < 3) {
            sum += x++;
        }
        return sum; // 6
    }

    public static void main(String[] args) {
        Main t = new Main();
        int sum = t.compute();
        sum += t.compute();
        t.compute();
        System.out.println(sum);

    }
}

What is the result?
A . 9
B . An excep on is thrown at run me.
C . 3
D . 6

CORRECT ANSWER IS A.

146.
GIVEN:

public class Person {
    private String name;

    public void setName(String name) {
        String title = "Dr. ";
        System.out.println(title);
        name = title + name;
    }

    public String toString() {
        return name;
    }
}


class Test {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("Who");
        System.out.println(p);
    }
}

What is the result?
A . Dr. Who
B . Dr. Null
C . An excep on is thrown at run me.
D . null

CORRECT ANSWER IS D.

147.
GIVEN:

public class Person {
    private String name;

    public void setName(String name) {
        String title = "Dr. ";
        System.out.println(title);
        this.name = title + name;
    }

    public String toString() {
        return name;
    }
}


class Test {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("Who");
        System.out.println(p);
    }
}

What is the result?
A . Dr. Who
B . Dr. Null
C . An excep on is thrown at run me.
D . null

CORRECT ANSWER IS A.

148.
Which command line runs the main class com.acme.Main from the module com.example?
A . java --module-path mods com.example/com.acme.Main
B . java --classpath com.example.jar com.acme.Main
C . java --module-path mods -m com.example/com.acme.Main
D . java -classpath com.example.jar --m com.example/com.acme.Main

CORRECT ANSWER IS C.

149.
GIVEN:

 public static void main(String[] args) {
        List<Integer> even = List.of();
        even.add(0, 2);
        even.add(0,-2);
        even.add(0,-3);
        System.out.println(even);
    }

What is the output?
A . The compilati on fails.
B . [-1, -2, -3]
C . [-3, -2, -1]
D . A run me excep tion is thrown.

CORRECT ANSWER IS D.

150.
GIVEN:

 public static void main(String[] args) {
        List<Integer> even = List.of();
        even.add(0, 2);
        even.add(0,-2);
        even.add(0,-3);
        System.out.println(even);
    }

What is the output?
A . The compilati on fails.
B . [-1, 2, -3]
C . [-3, -2, 2]
D . A run me excep tion is thrown.

CORRECT ANSWER IS C.

151.
Which statement about access modifiers is correct?
A . An instance variable can be declared with the sta c modifier.
B . A local variable can be declared with the final modifier.
C . An abstract method can be declared with the private modifier.
D . An inner class cannot be declared with the public modifier.
E . An interface can be declared with the protected modifier.

CORRECT ANSWER IS B.

152.
GIVEN:

        List<String> list = null;
        list.forEach( x -> {System.out.println(x);});

What is the type of x?
A . char
B . List<Character>
C . String
D . List<String>

CORRECT ANSWER IS C.

153. 
for 155.
